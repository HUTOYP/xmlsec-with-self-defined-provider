<!DOCTYPE html PUBLIC "-//IETF//DTD HTML//EN">
<!-- saved from url=(0076)http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=GBK">

<title>Java Cryptography Extension</title>
<meta name="collection" content="reference">

</head>

<body bgcolor="#ffffff" youdao="bind" ryt12496="1">
<hr>

<center>

<h1>Java<sup><font size="-2">TM</font></sup> Cryptography Extension (JCE)</h1>

<h1>Reference Guide</h1>

<h2>for the Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition, 
v 1.4</h2>

</center>

<hr>

<p></p><dl>

<dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#Introduction">
<font size="+2"><b>Introduction</b></font></a>
<br>
<br>

</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#WhatsNew">
<font size="+2"><b>What's New in JCE in the Java 2 SDK, v 1.4</b></font></a>
<br>
<br>

</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#Concepts">
<font size="+2"><b>Cryptographic Concepts</b></font></a>
<dl>
<dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#EncrDecr">
<b>Encryption and Decryption</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#PBE">
<b>Password-Based Encryption</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#Cipher">
<b>Cipher</b>
</a></dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#KeyAgree">
<b>Key Agreement</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#MAC">
<b>Message Authentication Code</b></a>
</dd></dl>
<br>

</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#CoreClasses">
<font size="+2"><b>Core Classes</b></font></a>
<dl>

<dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#CipherClass">
<b>The Cipher Class</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#CipherStream">
<b>The Cipher Stream Classes</b></a>
<dl>
<dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#CipherInput">
<b>The CipherInputStream Class</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#CipherOutput">
<b>The CipherOutputStream Class</b></a>
</dd></dl>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#KeyGenerator">
<b>The KeyGenerator Class</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#SecretFactory">
<b>The SecretKeyFactory Class</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#SealedObject">
<b>The SealedObject Class</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#KeyAgreement">
<b>The KeyAgreement Class</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#Mac">
<b>The Mac Class</b></a>
</dd></dl>
<br>

</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#ExemptApps">
<font size="+2"><b>How to Make Applications "Exempt" from Cryptographic 
Restrictions</b></font></a>
<br>
<br>

</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#InstallProvider">
<font size="+2"><b>Installing JCE Providers for the Java 2 SDK, v 1.4</b></font></a>

<br>
<br>

</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#JceKeystore">
<font size="+2"><b>JCE Keystore</b></font></a>
<br>
<br>

</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#Examples">
<font size="+2"><b>Code Examples</b></font></a>
<dl>
<dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#SimpleEncrEx">
<b>Using Encryption</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#PBEEx">
<b>Using Password-Based Encryption</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#KeyAgreeEx">
<b>Using Key Agreement</b></a>
</dd></dl>
<br>
<br>

</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppA">
<font size="+2"><b>Appendix A: Standard Names</b></font></a>
<br>
<br>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppB">
<font size="+2"><b>Appendix B: SunJCE Default Keysizes</b></font></a>
<br>
<br>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppC">
<font size="+2"><b>Appendix C: SunJCE Keysize Restrictions</b></font></a>
<br>
<br>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppD">
<font size="+2"><b>Appendix D: Jurisdiction Policy File Format</b></font></a>
<br>
<br>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppE">
<font size="+2"><b>Appendix E: Maximum Key Sizes Allowed by "Strong"
Jurisdiction Policy Files</b></font></a>
<br>
<br>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppF">
<font size="+2"><b>Appendix F: Sample Programs</b></font></a><dl>
<dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#DH2Ex">
<b>Diffie-Hellman Key Exchange between 2 Parties</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#DH3Ex">
<b>Diffie-Hellman Key Exchange between 3 Parties</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#BlowKeyEx">
<b>Blowfish Example</b></a>
</dd><dt></dt><dd><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#HmacEx">
<b>HMAC-MD5 Example</b></a>
</dd></dl>
</dd></dl>

<hr>

<h1><a name="Introduction">Introduction</a></h1>

<blockquote>

<p> This document is intended as a companion to the 
<a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/CryptoSpec.html">
Java<sup><font size="-2">TM</font></sup> Cryptography Architecture (JCA)
API Specification &amp; Reference</a>. References to chapters not
present in this document are to chapters in the JCA Specification.

</p><p> The Java<sup><font size="-2">TM</font></sup> Cryptography Extension
(JCE) provides a framework and implementations for encryption, key
generation and key agreement, and Message Authentication Code (MAC)
algorithms. Support for encryption includes symmetric, asymmetric,
block, and stream ciphers. The software also supports secure streams
and sealed objects.

</p><p>JCE was previously an optional package (extension) to the
Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition
(Java 2 SDK), versions 1.2.x and 1.3.x. JCE has now been integrated into the 
Java 2 SDK, v 1.4.

</p><p> JCE is based on the same
<a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/CryptoSpec.html#Design">design
principles</a> found elsewhere in the JCA: implementation independence
and, whenever possible, algorithm independence. It uses the same <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/CryptoSpec.html#ProviderArch">"provider"</a>
architecture. Providers signed by a trusted entity can be plugged into the JCE framework, and new algorithms can be added seamlessly.

</p><p> The JCE API covers:

</p><ul>

<li>Symmetric bulk encryption, such as DES, RC2, and IDEA<p>

</p></li><li>Symmetric stream encryption, such as RC4<p>

</p></li><li>Asymmetric encryption, such as RSA<p>

</p></li><li>Password-based encryption (PBE)<p>

</p></li><li>Key Agreement<p>

</p></li><li>Message Authentication Codes (MAC)

</li></ul>

<p>The Java 2 SDK, v 1.4 release comes standard with a JCE  
provider named "<code>SunJCE</code>", which comes pre-installed and
registered and which supplies the following 
cryptographic services:

</p><ul>

<li>An implementation of the DES (FIPS PUB 46-1), Triple DES, and
Blowfish encryption algorithms in the Electronic Code Book (ECB),
Cipher Block Chaining (CBC), Cipher Feedback (CFB), Output Feedback
(OFB), and Propagating Cipher Block Chaining (PCBC) modes. (Note:
Throughout this document, the terms "Triple DES" and "DES-EDE" will be
used interchangeably.)<p>

</p></li><li>Key generators for generating keys suitable for the DES, Triple
DES, Blowfish, HMAC-MD5, and HMAC-SHA1 algorithms.<p>

</p></li><li>An implementation of the MD5 with DES-CBC password-based encryption
(PBE) algorithm defined in PKCS #5.<p>

</p></li><li>"Secret-key factories" providing bi-directional conversions
between opaque DES, Triple DES and PBE key objects and transparent
representations of their underlying key material.<p>

</p></li><li>An implementation of the Diffie-Hellman key agreement algorithm between
two or more parties.<p>

</p></li><li>A Diffie-Hellman key pair generator for generating a pair of public and
private values suitable for the Diffie-Hellman algorithm.<p>

</p></li><li>A Diffie-Hellman algorithm parameter generator.<p>

</p></li><li>A Diffie-Hellman "key factory" providing bi-directional conversions
between opaque Diffie-Hellman key objects and transparent representations of
their underlying key material.<p>

</p></li><li>Algorithm parameter managers for Diffie-Hellman, DES, Triple DES,
Blowfish, and PBE parameters.<p>

</p></li><li>An implementation of the HMAC-MD5 and HMAC-SHA1 keyed-hashing algorithms
defined in RFC 2104.<p>

</p></li><li>An implementation of the padding scheme described in PKCS #5.<p>

</p></li><li>A keystore implementation for the proprietary keystore type named "JCEKS".

</li></ul>


<h3><a name="Terminology">A Note on Terminology</a></h3>

<blockquote>

<p> The JCE within the Java 2 SDK, v 1.4 includes two software components:

</p><ul>
<li>the framework that defines and supports cryptographic services 
that providers can supply implementations for.
This framework includes everything in 
the <code>javax.crypto</code> package. <p> 
</p></li><li>a provider named "SunJCE"
</li></ul>

Throughout this document, the term "JCE" by itself refers to the JCE 
framework in the Java 2 SDK, v 1.4. Whenever the JCE provider supplied with
the Java 2 SDK, v 1.4 is mentioned, it will be
referred to explicitly as the "SunJCE" provider.

</blockquote>


</blockquote>

<br>


<h1><a name="WhatsNew">What's New in JCE in the Java 2 SDK, v 1.4</a></h1>

<blockquote>

<p> Here are the differences between JCE 1.2.1 and the
JCE within the Java 2 SDK, v 1.4:

</p><ul>
<li><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#InJ2">JCE Is Now in Java 2 SDK</a><p>
</p></li><li><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#StrongCrypto">Strong Cryptography Is the Default, Unlimited Is 
Available</a><p>
</p></li><li><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#NoFwAuthentication">Provider Authentication of JCE
Framework No Longer Required</a><p>
</p></li><li><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#PKCSSupp">Support for Additional Features of PKCS #1, #5 and #8</a><p>
</p></li><li><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#BlowfishKS">SunJCE Default Blowfish Keysize Has Changed</a>
</li></ul>



<h3><a name="InJ2">JCE Is Now in Java 2 SDK</a></h3>

<blockquote>

<p>JCE was previously an optional package (extension) to the
Java<sup><font size="-2">TM</font></sup> 2 SDK, Standard Edition (Java 2 SDK), 
versions 1.2.x and 1.3.x. JCE has now been integrated into 
the Java 2 SDK, v 1.4.  The SunJCE provider is also included and is automatically
registered in the <code>java.security</code> security properties file
included with the Java 2 SDK, v 1.4.

</p></blockquote>


<h3><a name="StrongCrypto">Strong Cryptography Is the Default, Unlimited Is 
Available</a></h3>

<blockquote>

<p>Due to import control restrictions, the jurisdiction policy files 
shipped with the Java 2 SDK, v 1.4 allow "strong" but limited cryptography 
to be used. An "unlimited strength" version of these files indicating no 
restrictions on cryptographic strengths is available for those living in
eligible countries (which is most countries). You can download this version 
and replace the strong cryptography versions supplied with the Java 2 SDK, v 1.4  
with the unlimited ones.  See

</p><blockquote>
<a href="http://java.sun.com/products/jce/index-14.html">
http://java.sun.com/products/jce/index-14.html</a> 
</blockquote>

for information indicating where to go to download the unlimited version.

<p>The jurisdiction policy files have been relocated to 

</p><blockquote><pre>&lt;java-home&gt;\lib\security         [Windows]
&lt;java-home&gt;/lib/security         [Solaris]
</pre></blockquote>

where <tt>&lt;java-home&gt;</tt> refers to the directory where the 
runtime software is installed, which is the top-level directory of the 
Java<sup><font size="-2">TM</font></sup> 2 Runtime Environment (JRE)
or the <tt>jre</tt> directory in the 
Java<sup><font size="-2">TM</font></sup> 2 SDK (Java 2 SDK) software.
They have been moved to this standard location so that it is
easy to replace the strong cryptography versions that come with
the Java 2 SDK, v 1.4 with the unlimited ones.

</blockquote>


<h3><a name="NoFwAuthentication">Provider Authentication of JCE
Framework No Longer Required</a></h3>

<blockquote>

<p>In JCE 1.2.1, providers needed to include code to authenticate 
the JCE framework to assure themselves of the integrity and
authenticity of the JCE that they plugged into. Now that JCE
is integrated into the Java 2 SDK, v 1.4, this is no longer necessary.

</p><p>JCE 1.2.1 providers which follow the guidance in 
<a href="http://java.sun.com/products/jce/doc/guide/HowToImplAProvider.html">
How to Implement a Provider for the Java Cryptography Extension 1.2.1</a>
will continue to work with the JCE framework in the Java 2 SDK, v 1.4.

</p><p>However, a provider whose framework authentication code 
locates the JCE framework via protection
domain instead of following the recommendations in the
aforementioned JCE 1.2.1 JCE provider document will not work 
in the Java 2 SDK, v 1.4. Now that JCE has been
integrated into the Java 2 SDK, v 1.4, the JCE framework has a null 
code source just like any other class in the Java 2 SDK, v 1.4.
Provider vendors can either modify their provider to follow the recommended
approach for authenticating the framework, or put in a conditional 
so that the framework authentication code is only executed 
when the provider is being run with JCE 1.2.1.

</p></blockquote>




<h3><a name="PKCSSupp">Support for Additional Features of PKCS #1, #5 and #8</a></h3>

<blockquote>

<p>JCE and JCA have been enhanced to support the additional features of 
PKCS #1, #5 and #8. The following classes were added:

</p><ul>

<li><a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/security/spec/RSAOtherPrimeInfo.html">
java.security.spec.RSAOtherPrimeInfo</a>

</li><li><a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/security/spec/RSAMultiPrimePrivateCrtKeySpec.html">
java.security.spec.RSAMultiPrimePrivateCrtKeySpec</a>

</li><li><a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/security/interfaces/RSAMultiPrimePrivateCrtKey.html">
java.security.interfaces.RSAMultiPrimePrivateCrtKey</a>

</li><li><a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/security/spec/PSSParameterSpec.html">
java.security.spec.PSSParameterSpec</a>

</li><li><a href="http://docs.oracle.com/javase/1.4.2/docs/api/javax/crypto/interfaces/PBEKey.html">
javax.crypto.interfaces.PBEKey</a>

</li><li><a href="http://docs.oracle.com/javase/1.4.2/docs/api/javax/crypto/EncryptedPrivateKeyInfo.html">
javax.crypto.EncryptedPrivateKeyInfo</a>

</li></ul>

<p>The following methods were added to the
<a href="http://docs.oracle.com/javase/1.4.2/docs/api/javax/crypto/spec/PBEKeySpec.html">
javax.crypto.spec.PBEKeySpec</a> class:

</p><blockquote>
<pre>public PBEKeySpec(char[] password, byte[] salt, 
    int iterationCount, int keyLength)
public PBEKeySpec(char[] password, byte[] salt, 
    int iterationCount)
public final void clearPassword()
public final byte[] getSalt()
public final int getIterationCount()
public final int getKeyLength()
</pre>
</blockquote>

</blockquote>



<h3><a name="BlowfishKS">SunJCE Default Blowfish Keysize Has Changed</a></h3>

<blockquote>

<p>The SunJCE provider's default keysize for the Blowfish algorithm has changed
from 56 bytes to 56 bits.

</p></blockquote>


</blockquote>


<br>


<h1><a name="Concepts">Cryptographic Concepts</a></h1>

<blockquote>

<p> This section provides a high-level description of the concepts
implemented by the API, and the exact meaning of the technical terms
used in the API specification.

</p><h4><a name="EncrDecr">Encryption and Decryption</a></h4>

<p> Encryption is the process of taking data (called <i>cleartext</i>)
and a short string (a <i>key</i>), and producing data
(<i>ciphertext</i>) meaningless to a third-party who does not know the
key. Decryption is the inverse process: that of taking ciphertext and
a short key string, and producing cleartext.

</p><h4><a name="PBE">Password-Based Encryption</a></h4>

<p> Password-Based Encryption (PBE) derives an encryption key from a
password. In order to make the task of getting from password to key
very time-consuming for an attacker, most PBE implementations will mix
in a random number, known as a <i>salt</i>, to create the key.

</p><h4><a name="Cipher">Cipher</a></h4>

<p> Encryption and decryption are done using a cipher. A cipher is an
object capable of carrying out encryption and decryption according to
an encryption scheme (algorithm).

</p><h4><a name="KeyAgree">Key Agreement</a></h4>

<p> Key agreement is a protocol by which 2 or more parties can
establish the same cryptographic keys, without having to exchange any
secret information.</p><p>

</p><h4><a name="MAC">Message Authentication Code</a></h4>

<p> A Message Authentication Code (MAC) provides a way to check the integrity
of information
transmitted over or stored in an unreliable medium, based on a secret
key. Typically, message authentication codes are used between two
parties that share a secret key in order to validate information
transmitted between these parties.

</p><p> A MAC mechanism that is based on cryptographic hash functions is
referred to as HMAC. HMAC can be used with any cryptographic hash function,
e.g., MD5 or SHA-1, in combination with a secret shared key. HMAC is
specified in RFC 2104.

</p></blockquote>

<br>



<h1><a name="CoreClasses">Core Classes</a></h1>

<blockquote>

<ul>

<li><h2><a name="CipherClass">The Cipher Class</a></h2>

<blockquote>

<p> The Cipher class provides the functionality of a cryptographic
cipher used for encryption and decryption. It forms the core of the
JCE framework.

</p><h4>Creating a Cipher Object</h4>

<blockquote>

<p> Like other engine classes in the API, Cipher objects are created
using the <code>getInstance</code> factory methods of the Cipher
class.  A factory method is a static method that returns an instance
of a class, in this case, an instance of <code>Cipher</code>, which
implements a requested <i>transformation</i>.

</p><p> To create a Cipher object, you must specify the transformation
name. You may also specify which provider you want to supply the
implementation of the requested transformation:

</p><pre>    public static Cipher getInstance(String transformation);

    public static Cipher getInstance(String transformation,
                                     String provider);
</pre>

<p> If just a transformation name is specified, the system will
determine if there is an implementation of the requested
transformation available in the environment, and if there is more than
one, if there is a preferred one.

</p><p> If both a transformation name and a package provider are
specified, the system will determine if there is an implementation of
the requested transformation in the package requested, and throw an
exception if there is not.

</p><p><a name="trans"> A transformation is a string that describes the
operation (or set of operations) to be performed on the given input,
to produce some output. A transformation always includes the name of a
cryptographic algorithm (e.g., <code>DES</code>), and may be followed
by a mode and padding scheme.

</a></p><p><a name="trans"> A transformation is of the form:</a></p><p><a name="trans">

</a></p><ul><a name="trans">
<li>"<i>algorithm/mode/padding</i>" or
<p>
</p></li><li>"<i>algorithm</i>"
</li></a></ul><a name="trans">

<p> For example, the following are valid transformations:</p><p>

</p><pre>    "<i>DES/CBC/PKCS5Padding</i>"

    "<i>DES</i>"
</pre>

<p> If no mode or padding have been specified, provider-specific
default values for the mode and padding scheme are used. For example,
the SunJCE provider uses <code>ECB</code> as the default mode, and
<code>PKCS5Padding</code> as the default padding scheme for
<code>DES</code>, <code>DES-EDE</code> and <code>Blowfish</code>
ciphers. This means that in the case of the SunJCE provider,

</p><p>
</p><pre>    Cipher c1 = Cipher.getInstance("<i>DES/ECB/PKCS5Padding</i>");
</pre>
<p>

and

</p><p>
</p><pre>    Cipher c1 = Cipher.getInstance("<i>DES</i>");
</pre>
<p>

are equivalent statements.

</p><p> When requesting a block cipher in stream cipher mode (e.g.,
<code>DES</code> in <code>CFB</code> or <code>OFB</code> mode), you
may optionally specify the number of bits to be processed at a time,
by appending this number to the mode name as shown in the
"<i>DES/CFB8/NoPadding</i>" and "<i>DES/OFB32/PKCS5Padding</i>"
transformations. If no such number is specified, a provider-specific
default is used. (For example, the SunJCE provider uses a default of
64 bits.)

</p></a><p><a name="trans"> </a><a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppA">Appendix A</a> of this document contains a list of
standard names that can be used to specify the algorithm name, mode,
and padding scheme components of a transformation.

</p><p> The objects returned by factory methods are uninitialized, and
must be initialized before they become usable.

</p></blockquote>

<h4><a name="InitaCipher">Initializing a Cipher Object</a></h4>

<blockquote>

<p> A Cipher object obtained via <code>getInstance</code> must be
initialized for one of four modes, which are
defined as final integer constants in the <code>Cipher</code>
class. The modes can be referenced by their symbolic names, which
are shown below along with a description of the purpose of
each mode:</p><p>

</p><ul>

<li>ENCRYPT_MODE<p>
</p><blockquote>
Encryption of data.
</blockquote>

</li><li>DECRYPT_MODE<p>
</p><blockquote>
Decryption of data.
</blockquote>

</li><li>WRAP_MODE<p>
</p><blockquote>
Wrapping a Key into bytes so that the key can be securely transported.
</blockquote>

</li><li>UNWRAP_MODE<p>
</p><blockquote>
Unwrapping of a previously wrapped key into a 
<code>java.security.Key</code> object. 
</blockquote>


</li></ul>

<p> Each of the Cipher initialization methods takes a mode parameter
(<code>opmode</code>), and initializes the Cipher object for that
mode. Other parameters include the key (<code>key</code>) or
certificate containing the key (<code>certificate</code>), algorithm
parameters (<code>params</code>), and a source of randomness
(<code>random</code>).

</p><p> To initialize a Cipher object, call one of the following <code>init</code>
methods:

</p><pre>    public void init(int opmode, Key key);

    public void init(int opmode, Certificate certificate)

    public void init(int opmode, Key key, 
                     SecureRandom random);

    public void init(int opmode, Certificate certificate, 
                     SecureRandom random)

    public void init(int opmode, Key key,
                     AlgorithmParameterSpec params);

    public void init(int opmode, Key key,
                     AlgorithmParameterSpec params,
                     SecureRandom random);

    public void init(int opmode, Key key,
                     AlgorithmParameters params)

    public void init(int opmode, Key key,
                     AlgorithmParameters params,
                     SecureRandom random)
</pre>

<p> If a Cipher object that requires parameters (e.g., an
initialization vector) is initialized for encryption, and no
parameters are supplied to the <code>init</code> method, the
underlying cipher implementation is supposed to supply the required
parameters itself, either by generating random parameters or by using
a default, provider-specific set of parameters.

</p><p> However, if a Cipher object that requires parameters is
initialized for decryption, and no parameters are supplied to the
<code>init</code> method, an <code>InvalidKeyException</code> or
<code>InvalidAlgorithmParameterException</code> exception will be
raised, depending on the <code>init</code> method that was used.

</p><p> See the section about <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#ManagingParameters">Managing Algorithm Parameters</a> for more details.

</p><p> The same parameters that were used for encryption must be used for
decryption.

</p><p> Note that when a Cipher object is initialized, it loses all
previously-acquired state. In other words, initializing a Cipher is
equivalent to creating a new instance of that Cipher, and initializing
it. For example, if a Cipher is first initialized for decryption with
a given key, and then initialized for encryption, it will lose any
state acquired while in decryption mode.

</p></blockquote>

<h4><a name="EncrDecr">Encrypting and Decrypting Data</a></h4>

<blockquote>

<p> Data can be encrypted or decrypted in one step (<i>single-part
operation</i>) or in multiple steps (<i>multiple-part
operation</i>). A multiple-part operation is useful if you do not know
in advance how long the data is going to be, or if the data is too
long to be stored in memory all at once.

</p><p> To encrypt or decrypt data in a single step, call one of the
<code>doFinal</code> methods:

</p><pre>    public byte[] doFinal(byte[] input);

    public byte[] doFinal(byte[] input, int inputOffset,
                          int inputLen);

    public int doFinal(byte[] input, int inputOffset, 
                       int inputLen, byte[] output);

    public int doFinal(byte[] input, int inputOffset, 
                       int inputLen, byte[] output, int outputOffset)
</pre>

<p> To encrypt or decrypt data in multiple steps, call one of the
<code>update</code> methods:

</p><pre>    public byte[] update(byte[] input);

    public byte[] update(byte[] input, int inputOffset, int inputLen);

    public int update(byte[] input, int inputOffset, int inputLen,
                      byte[] output);

    public int update(byte[] input, int inputOffset, int inputLen,
                      byte[] output, int outputOffset)
</pre>

<p> A multiple-part operation must be terminated by one of the above
<code>doFinal</code> methods (if there is still some input data left
for the last step), or by one of the following <code>doFinal</code>
methods (if there is no input data left for the last step):

</p><pre>    public byte[] doFinal();

    public int doFinal(byte[] output, int outputOffset);
</pre>

<p> All the <code>doFinal</code> methods take care of any necessary
padding (or unpadding), if padding (or unpadding) was requested as
part of the specified transformation.

</p><p> A call to <code>doFinal</code> resets the Cipher object to the
state it was in when initialized via a call to
<code>init</code>. That is, the Cipher object is reset and available to
encrypt or decrypt (depending on the operation mode that was specified
in the call to <code>init</code>) more data.

</p></blockquote>


<h4><a name="WrapUnwrap">Wrapping and Unwrapping Keys</a></h4>

<blockquote>

<p> Wrapping a key enables secure transfer of the key from one
place to another. 

</p><p> The <code>wrap/unwrap</code> API makes it more convenient 
to write code since it works with key objects directly. These methods
also enable the possibility of secure transfer of hardware-based keys.

</p><p> To <b>wrap</b> a Key, first initialize the Cipher object for
WRAP_MODE, and then call the following:

</p><pre>    public final byte[] wrap(Key key);
</pre>

<p> If you are supplying the wrapped key bytes (the result of
calling <code>wrap</code>) to someone else who will unwrap them,
be sure to also send additional information the recipient will need
in order to do the <code>unwrap</code>:</p><p> 

</p><ol>
<li>the name of the key algorithm, and<p> 
</p></li><li>the type of the wrapped key (one of 
<code>Cipher.SECRET_KEY</code>, <code>Cipher.PRIVATE_KEY</code>, or
<code>Cipher.PUBLIC_KEY</code>).
</li></ol>

<p> The key algorithm name can be determined by calling the
<code>getAlgorithm</code> method from the Key interface:

</p><pre>    public String getAlgorithm();
</pre>


<p> To <b>unwrap</b> the bytes returned by a previous call to
<code>wrap</code>, first initialize a Cipher object for
UNWRAP_MODE, then call the following:

</p><pre>    public final Key unwrap(byte[] wrappedKey,
                            String wrappedKeyAlgorithm,
                            int wrappedKeyType));
</pre>

<p> Here, <code>wrappedKey</code> is the bytes returned
from the previous call to wrap, <code>wrappedKeyAlgorithm</code>
is the algorithm associated with the wrapped key,
and <code>wrappedKeyType</code> is the type of the 
wrapped key. This must be one of
<code>Cipher.SECRET_KEY</code>, <code>Cipher.PRIVATE_KEY</code>, or
<code>Cipher.PUBLIC_KEY</code>.

</p></blockquote>


<h4><a name="ManagingParameters">Managing Algorithm Parameters</a></h4>

<blockquote>

<p> The parameters being used by the underlying Cipher implementation,
which were either explicitly passed to the <code>init</code> method by
the application or generated by the underlying implementation itself,
can be retrieved from the Cipher object by calling its
<code>getParameters</code> method, which returns the parameters as a
<code>java.security.AlgorithmParameters</code> object (or
<code>null</code> if no parameters are being used). If the parameter
is an initialization vector (IV), it can also be retrieved by calling
the <code>getIV</code> method.

</p><p> In the following example, a Cipher object implementing
password-based encryption is initialized with just a key and no
parameters. However, the selected algorithm for password-based encryption
requires two parameters - a <i>salt</i> and an <i>iteration count</i>.
Those will be generated by the underlying algorithm implementation
itself. The application can retrieve the generated parameters from the
Cipher object as follows:

</p><pre>    import javax.crypto.*;
    import java.security.AlgorithmParameters;

    // get cipher object for password-based encryption
    Cipher c = Cipher.getInstance("PBEWithMD5AndDES");

    // initialize cipher for encryption, without supplying
    // any parameters. Here, "myKey" is assumed to refer 
    // to an already-generated key.
    c.init(Cipher.ENCRYPT_MODE, myKey);
 
    // encrypt some data and store away ciphertext
    // for later decryption
    byte[] cipherText = c.doFinal("This is just an example".getBytes());

    // retrieve parameters generated by underlying cipher
    // implementation
    AlgorithmParameters algParams = c.getParameters();

    // get parameter encoding and store it away
    byte[] encodedAlgParams = algParams.getEncoded();
</pre>

<p> The same parameters that were used for encryption must be used for
decryption. They can be instantiated from their encoding and used to
initialize the corresponding Cipher object for decryption, as follows:

</p><pre>    import javax.crypto.*;
    import java.security.AlgorithmParameters;

    // get parameter object for password-based encryption
    AlgorithmParameters algParams;
    algParams = 
      AlgorithmParameters.getInstance("PBEWithMD5AndDES");

    // initialize with parameter encoding from above
    algParams.init(encodedAlgParams);

    // get cipher object for password-based encryption
    Cipher c = Cipher.getInstance("PBEWithMD5AndDES");

    // initialize cipher for decryption, using one of the 
    // init() methods that takes an AlgorithmParameters 
    // object, and pass it the algParams object from above
    c.init(Cipher.DECRYPT_MODE, myKey, algParams);
</pre>

<p> If you did not specify any parameters when you initialized a
Cipher object, and you are not sure whether or not the underlying
implementation uses any parameters, you can find out by simply calling
the <code>getParameters</code> method of your Cipher object and
checking the value returned. A return value of <code>null</code> indicates
that no parameters were used.

</p><p> The following cipher algorithms implemented by the SunJCE provider
use parameters:</p><p>

</p><ul>
<li> DES, DES-EDE, and Blowfish, when used in feedback (i.e., CBC, CFB,
OFB, or PCBC) mode, use an initialization vector (IV). The
<code>javax.crypto.spec.IvParameterSpec</code> class can be used to
initialize a Cipher object with a given IV.
<p>
</p></li><li> PBEWithMD5AndDES uses a set of parameters, comprising a salt and
an iteration count. The <code>javax.crypto.spec.PBEParameterSpec</code>
class can be used to initialize a Cipher object implementing
PBEWithMD5AndDES with a given salt and iteration count.
</li></ul>

<p> Note that you do not have to worry about storing or transferring
any algorithm parameters for use by the decryption operation if you
use the <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#SealedObject"><code>SealedObject</code></a>
class. This class attaches the parameters used for sealing
(encryption) to the encrypted object contents, and uses the same
parameters for unsealing (decryption).

</p></blockquote>

<h4>Cipher Output Considerations</h4>

<blockquote>

<p> Some of the <code>update</code> and <code>doFinal</code> methods
of Cipher allow the caller to specify the output buffer into which to
encrypt or decrypt the data. In these cases, it is important to pass a
buffer that is large enough to hold the result of the encryption or
decryption operation.

</p><p> The following method in Cipher can be used to determine how big
the output buffer should be:

</p><pre>    public int getOutputSize(int inputLen)
</pre>

</blockquote>

</blockquote>

</li><li><h2><a name="CipherStream">The Cipher Stream Classes</a></h2>

<blockquote>

<p> JCE introduces the concept of secure streams, which combine an
InputStream or OutputStream with a Cipher object. Secure streams are
provided by the <code>CipherInputStream</code> and
<code>CipherOutputStream</code> classes.

</p><blockquote>

<ul>

<li><h3><a name="CipherInput">The CipherInputStream Class</a></h3>

<blockquote>

<p> This class is a <code>FilterInputStream</code> that encrypts or
decrypts the data passing through it. It is composed of an
<code>InputStream</code>, or one of its subclasses, and a
<code>Cipher</code>. CipherInputStream represents a secure input
stream into which a Cipher object has been interposed. The
<code>read</code> methods of CipherInputStream return data that are
read from the underlying InputStream but have additionally been
processed by the embedded Cipher object. The Cipher object must be
fully initialized before being used by a CipherInputStream.

</p><p> For example, if the embedded Cipher has been initialized for
decryption, the CipherInputStream will attempt to decrypt the data it
reads from the underlying InputStream before returning them to the
application.

</p><p> This class adheres strictly to the semantics, especially the
failure semantics, of its ancestor classes
<code>java.io.FilterInputStream</code> and
<code>java.io.InputStream</code>.  This class has exactly those
methods specified in its ancestor classes, and overrides them all, so
that the data are additonally processed by the embedded cipher.
Moreover, this class catches all exceptions that are not thrown by its
ancestor classes.  In particular, the <code>skip(long)</code> method
skips only data that have been processed by the Cipher.

</p><p> It is crucial for a programmer using this class not to use methods
that are not defined or overridden in this class (such as a new method
or constructor that is later added to one of the super classes),
because the design and implementation of those methods are unlikely to
have considered security impact with regard to CipherInputStream.

</p><p> As an example of its usage, suppose <code>cipher1</code> has been initialized for encryption. The code below
demonstrates how to use a CipherInputStream containing
that cipher and a FileInputStream in order to encrypt input stream data:

</p><pre>    FileInputStream fis;
    FileOutputStream fos;
    CipherInputStream cis;

    fis = new FileInputStream("/tmp/a.txt");
    cis = new CipherInputStream(fis, cipher1);
    fos = new FileOutputStream("/tmp/b.txt");
    byte[] b = new byte[8];
    int i = cis.read(b);
    while (i != -1) {
        fos.write(b, 0, i);
        i = cis.read(b);
    }
</pre>

<p> The above program reads and encrypts the content from the file
<code>/tmp/a.txt</code> and then stores the result (the encrypted bytes) in
<code>/tmp/b.txt</code>.

</p><p> The following example demonstrates how to easily connect several 
instances of CipherInputStream and FileInputStream. In this example,
assume that <code>cipher1</code> and
<code>cipher2</code> have been initialized for encryption and
decryption (with corresponding keys), respectively. 

</p><pre>    FileInputStream fis;
    FileOutputStream fos;
    CipherInputStream cis1, cis2;

    fis = new FileInputStream("/tmp/a.txt");
    cis1 = new CipherInputStream(fis, cipher1);
    cis2 = new CipherInputStream(cis1, cipher2);
    fos = new FileOutputStream("/tmp/b.txt");
    byte[] b = new byte[8];
    int i = cis2.read(b);
    while (i != -1) {
        fos.write(b, 0, i);
        i = cis2.read(b);
    }
</pre>

<p>The above program copies the content from file <code>/tmp/a.txt</code> to
<code>/tmp/b.txt</code>, except that the content is first encrypted and then
decrypted back when it is read from <code>/tmp/a.txt</code>. Of course since 
this program 
simply encrypts text and decrypts it back right away, it's actually not very
useful except as a simple way of illustrating chaining of 
CipherInputStreams.

</p></blockquote>

</li><li><h3><a name="CipherOutput">The CipherOutputStream Class</a></h3>

<blockquote>

<p> This class is a <code>FilterOutputStream</code> that encrypts or
decrypts the data passing through it. It is composed of an
<code>OutputStream</code>, or one of its subclasses, and a
<code>Cipher</code>. CipherOutputStream represents a secure output
stream into which a Cipher object has been interposed. The
<code>write</code> methods of CipherOutputStream first process the
data with the embedded Cipher object before writing them out to the
underlying OutputStream. The Cipher object must be fully initialized
before being used by a CipherOutputStream.

</p><p> For example, if the embedded Cipher has been initialized for
encryption, the CipherOutputStream will encrypt its data, before
writing them out to the underlying output stream.

</p><p> This class adheres strictly to the semantics, especially the
failure semantics, of its ancestor classes <code>java.io.OutputStream</code> and
<code>java.io.FilterOutputStream</code>.  This class has exactly those methods
specified in its ancestor classes, and overrides them all, so that all
data are additionally processed by the embedded cipher.  Moreover,
this class catches all exceptions that are not thrown by its ancestor
classes.

</p><p> It is crucial for a programmer using this class not to use methods
that are not defined or overridden in this class (such as a new method
or constructor that is later added to one of the super classes),
because the design and implementation of those methods are unlikely to
have considered security impact with regard to CipherOutputStream.

</p><p> As an example of its usage, suppose <code>cipher1</code> has been initialized for encryption. The code below
demonstrates how to use a CipherOutputStream containing
that cipher and a FileOutputStream in order to encrypt data
to be written to an output stream:

</p><pre>    FileInputStream fis;
    FileOutputStream fos;
    CipherOutputStream cos;

    fis = new FileInputStream("/tmp/a.txt");
    fos = new FileOutputStream("/tmp/b.txt");
    cos = new CipherOutputStream(fos, cipher1);
    byte[] b = new byte[8];
    int i = fis.read(b);
    while (i != -1) {
        cos.write(b, 0, i);
        i = fis.read(b);
    }
    cos.flush();
</pre>

<p> The above program reads the content from the file
<code>/tmp/a.txt</code>, then encrypts and stores the result 
(the encrypted bytes) in
<code>/tmp/b.txt</code>.

</p><p> The following example demonstrates how to easily connect several 
instances of CipherOutputStream and FileOutputStream. In this example,
assume that <code>cipher1</code> and
<code>cipher2</code> have been initialized for decryption and
encryption (with corresponding keys), respectively:

</p><pre>    FileInputStream fis;
    FileOutputStream fos;
    CipherOutputStream cos1, cos2;

    fis = new FileInputStream("/tmp/a.txt");
    fos = new FileOutputStream("/tmp/b.txt");
    cos1 = new CipherOutputStream(fos, cipher1);
    cos2 = new CipherOutputStream(cos1, cipher2);
    byte[] b = new byte[8];
    int i = fis.read(b);
    while (i != -1) {
        cos2.write(b, 0, i);
        i = fis.read(b);
    }
    cos2.flush();
</pre>
 
<p> The above program copies the content from file <code>/tmp/a.txt</code> to
<code>/tmp/b.txt</code>, except that the content is first encrypted and then
decrypted back before it is written to <code>/tmp/b.txt</code>.

</p><p> There is one important difference between the <code>flush</code>
and <code>close</code> methods of this class, which becomes even more
relevant if the encapsulated Cipher object implements a block cipher
algorithm with padding turned on:

</p><p> <code>flush</code> flushes the underlying OutputStream by forcing
any buffered output bytes that have already been processed by the
encapsulated Cipher object to be written out. Any bytes buffered by
the encapsulated Cipher object and waiting to be processed by it will
<b>not</b> be written out.

</p><p> <code>close</code> closes the underlying OutputStream and releases
any system resources associated with it. It invokes the
<code>doFinal</code> method of the encapsulated Cipher object, causing
any bytes buffered by it to be processed and written out to the
underlying stream by calling its <code>flush</code> method.


</p></blockquote>

</li></ul>

</blockquote>

</blockquote>

</li><li><h2><a name="KeyGenerator">The KeyGenerator Class</a></h2>

<blockquote>

<p> A key generator is used to generate secret keys for symmetric
algorithms.

</p><h4>Creating a Key Generator</h4>

<blockquote>

<p> Like other engine classes in the API, KeyGenerator objects are
created using the <code>getInstance</code> factory methods of the
KeyGenerator class.  A factory method is a static method that returns
an instance of a class, in this case, an instance of
<code>KeyGenerator</code> which provides an implementation of the
requested key generator.

</p><p><code>getInstance</code> takes as its argument the name of a
symmetric algorithm for which a secret key is to be
generated. Optionally, a package provider name may be specified:

</p><pre>    public static KeyGenerator getInstance(String algorithm);

    public static KeyGenerator getInstance(String algorithm,
                                           String provider);
</pre>

<p> If just an algorithm name is specified, the system will determine
if there is an implementation of the requested key generator available
in the environment, and if there is more than one, if there is a
preferred one.

</p><p> If both an algorithm name and a package provider are specified,
the system will determine if there is an implementation of the
requested key generator in the package requested, and throw an
exception if there is not.

</p></blockquote>

<h4>Initializing a KeyGenerator Object</h4>

<blockquote>

<p> A key generator for a particular symmetric-key algorithm creates a
symmetric key that can be used with that algorithm. It also associates
algorithm-specific parameters (if any) with the generated key.

</p><p> There are two ways to generate a key: in an algorithm-independent
manner, and in an algorithm-specific manner. The only difference
between the two is the initialization of the object:
</p><p>
 
</p><ul>
<li><b>Algorithm-Independent Initialization</b>

<p> All key generators share the concepts of a <i>keysize</i> and a
<i>source of randomness</i>. There is an <code>init</code> method that
takes these two universally shared types of arguments. There is also
one that takes just a <code>keysize</code> argument, and uses a
system-provided source of randomness, and one that takes just a source
of randomness:

</p><pre>    public void init(SecureRandom random);

    public void init(int keysize);

    public void init(int keysize, SecureRandom random);
</pre>

<p> Since no other parameters are specified when you call the above
algorithm-independent <code>init</code> methods, it is up to the
provider what to do about the algorithm-specific parameters (if any)
to be associated with the generated key.
</p><p>

</p></li><li><b>Algorithm-Specific Initialization</b>

<p> For situations where a set of algorithm-specific parameters
already exists, there are two <code>init</code> methods that have an
<code>AlgorithmParameterSpec</code> argument. One also has a
<code>SecureRandom</code> argument, while the source of randomness is
system-provided for the other:

</p><pre>    public void init(AlgorithmParameterSpec params);

    public void init(AlgorithmParameterSpec params,
                     SecureRandom random);
</pre>

</li></ul>

<p> In case the client does not explicitly initialize the KeyGenerator
(via a call to an <code>init</code> method), each provider must supply
(and document) a default initialization.

</p></blockquote>

<h4>Creating a Key</h4>

<blockquote>

The following method generates a secret key:

<pre>    public SecretKey generateKey();
</pre>

</blockquote>

</blockquote>

</li><li><h2><a name="SecretFactory">The SecretKeyFactory Class</a></h2>

<blockquote>

<p> This class represents a factory for secret keys.

</p><p> Key factories are used to convert <i>keys</i> (opaque
cryptographic keys of type <code>java.security.Key</code>) into <i>key
specifications</i> (transparent representations of the underlying key
material in a suitable format), and vice versa.

</p><p> A <code>javax.crypto.SecretKeyFactory</code> object operates only
on secret (symmetric) keys, whereas a <code>java.security.KeyFactory</code>
object processes the public and private key components of a key pair.

</p><p> Objects of type <code>java.security.Key</code>, of which
<code>java.security.PublicKey</code>,
<code>java.security.PrivateKey</code>, and
<code>javax.crypto.SecretKey</code> are subclasses, are opaque key
objects, because you cannot tell how they are implemented.  The
underlying implementation is provider-dependent, and may be software
or hardware based. Key factories allow providers to supply their own
implementations of cryptographic keys.

</p><p> For example, if you have a key specification for a Diffie Hellman
public key, consisting of the public value <code>y</code>, the prime
modulus <code>p</code>, and the base <code>g</code>, and you feed the
same specification to Diffie-Hellman key factories from different
providers, the resulting <code>PublicKey</code> objects will most
likely have different underlying implementations.

</p><p> A provider should document the key specifications supported by its
secret key factory. For example, the <code>SecretKeyFactory</code> for
DES keys supplied by the "SunJCE" provider supports <code>DESKeySpec</code>
as a transparent representation of DES keys, the
<code>SecretKeyFactory</code> for DES-EDE keys supports
<code>DESedeKeySpec</code> as a transparent representation of DES-EDE
keys, and the <code>SecretKeyFactory</code> for PBE supports
<code>PBEKeySpec</code> as a transparent representation of the
underlying password.

</p><p>The following is an example of how to use a
<code>SecretKeyFactory</code> to convert secret key data into a
<code>SecretKey</code> object, which can be used for a subsequent
<code>Cipher</code> operation:

</p><pre>    // Note the following bytes are not realistic secret key data 
    // bytes but are simply supplied as an illustration of using data
    // bytes (key material) you already have to build a DESKeySpec.
    byte[] desKeyData = { (byte)0x01, (byte)0x02, (byte)0x03, 
        (byte)0x04, (byte)0x05, (byte)0x06, (byte)0x07, (byte)0x08 };
    DESKeySpec desKeySpec = new DESKeySpec(desKeyData);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DES");
    SecretKey secretKey = keyFactory.generateSecret(desKeySpec);
</pre>

<p> In this case, the underlying implementation of
<code>secretKey</code> is based on the provider of
<code>keyFactory</code>.

</p><p> An alternative, provider-independent way of creating a
functionally equivalent <code>SecretKey</code> object from the same
key material is to use the
<code>javax.crypto.spec.SecretKeySpec</code> class, which implements
the <code>javax.crypto.SecretKey</code> interface:

</p><pre>    byte[] desKeyData = { (byte)0x01, (byte)0x02, ...};
    SecretKeySpec secretKey = new SecretKeySpec(desKeyData, "DES");
</pre>

</blockquote>

</li><li><h2><a name="SealedObject">The SealedObject Class</a></h2>

<blockquote>

<p> This class enables a programmer to create an object and protect
its confidentiality with a cryptographic algorithm.

</p><p> Given any object that implements the <code>java.io.Serializable</code>
interface, one can create a <code>SealedObject</code> that
encapsulates the original object, in serialized format (i.e., a "deep
copy"), and seals (encrypts) its serialized contents, using a
cryptographic algorithm such as DES, to protect its confidentiality.
The encrypted content can later be decrypted (with the corresponding
algorithm using the correct decryption key) and de-serialized,
yielding the original object.

</p><p> A typical usage is illustrated in the following code segment: In order
to seal an object, you create a <code>SealedObject</code> from the object
to be sealed and a fully initialized <code>Cipher</code> object that will
encrypt the serialized object contents. In this example, the String
"This is a secret" is sealed using the DES algorithm. Note that any 
algorithm parameters that may be used in the sealing operation are stored
inside of <code>SealedObject</code>: </p><p>

</p><pre>    // create Cipher object
    // Note: sKey is assumed to refer to an already-generated
    // secret DES key.
    Cipher c = Cipher.getInstance("DES");
    c.init(Cipher.ENCRYPT_MODE, sKey);

    // do the sealing
    SealedObject so = new SealedObject("This is a secret", c);
</pre>

<p> The original object that was sealed can be recovered in two different
ways: </p><p>

</p><ul>

<li>by using a <code>Cipher</code> object that has been initialized with the
exact same algorithm, key, padding scheme, etc., that were used to seal the
object:<p>

</p><pre>    c.init(Cipher.DECRYPT_MODE, sKey);
    try {
        String s = (String)so.getObject(c);
    } catch (Exception e) {
        // do something
    };
</pre>

<p> This approach has the advantage that the party who unseals the sealed
object does not require knowledge of the decryption key. For example,
after one party has initialized the cipher object with the required
decryption key, it could hand over the cipher object to
another party who then unseals the sealed object.

</p><p>

</p></li><li>by using the appropriate decryption key (since DES is a symmetric
encryption algorithm, we use the same key for sealing and unsealing):<p>

</p><pre>    try {
        String s = (String)so.getObject(sKey);
    } catch (Exception e) {
        // do something
    };
</pre>

<p> In this approach, the <code>getObject</code> method creates a
cipher object for the appropriate decryption algorithm and initializes
it with the given decryption key and the algorithm parameters (if any)
that were stored in the sealed object. This approach has the advantage
that the party who unseals the object does not need to keep track of
the parameters (e.g., the IV) that were used to seal the object.

</p></li></ul>

</blockquote>

</li><li><h2><a name="KeyAgreement">The KeyAgreement Class</a></h2>

<blockquote>

<p> The KeyAgreement class provides the functionality of a key
agreement protocol. The keys involved in establishing a shared secret
are created by one of the key generators
(<code>KeyPairGenerator</code> or <code>KeyGenerator</code>), a
<code>KeyFactory</code>, or as a result from an intermediate phase of
the key agreement protocol.

</p><h4>Creating a KeyAgreement Object</h4>

<blockquote>

<p> Each party involved in the key agreement has to create a
KeyAgreement object. Like other engine classes in the API,
KeyAgreement objects are created using the <code>getInstance</code>
factory methods of the KeyAgreement class.  A factory method is a
static method that returns an instance of a class, in this case, an
instance of <code>KeyAgreement</code> which provides the requested key
agreement algorithm.

</p><p><code>getInstance</code> takes as its argument the name of a key
agreement algorithm. Optionally, a package provider name may be
specified:

</p><pre>    public static KeyAgreement getInstance(String algorithm);

    public static KeyAgreement getInstance(String algorithm,
                                           String provider);
</pre>

<p> If just an algorithm name is specified, the system will determine
if there is an implementation of the requested key agreement available
in the environment, and if there is more than one, if there is a
preferred one.

</p><p> If both an algorithm name and a package provider are specified,
the system will determine if there is an implementation of the
requested key agreement in the package requested, and throw an
exception if there is not.

</p></blockquote>

<h4>Initializing a KeyAgreement Object</h4>

<blockquote>

<p> You initialize a KeyAgreement object with your private
information. In the case of Diffie-Hellman, you initialize it with
your Diffie-Hellman private key. Additional initialization information
may contain a source of randomness and/or a set of algorithm
parameters. Note that if the requested key agreement algorithm
requires the specification of algorithm parameters, and only a key,
but no parameters are provided to initialize the KeyAgreement object,
the key must contain the required algorithm parameters. (For example,
the Diffie-Hellman algorithm uses a prime modulus <code>p</code> and a
base generator <code>g</code> as its parameters.)

</p><p> To initialize a KeyAgreement object, call one of its <code>init</code>
methods:

</p><pre>    public void init(Key key);

    public void init(Key key, SecureRandom random);

    public void init(Key key, AlgorithmParameterSpec params);

    public void init(Key key, AlgorithmParameterSpec params,
                     SecureRandom random);
</pre>

</blockquote>

<h4>Executing a KeyAgreement Phase</h4>

<blockquote>

<p> Every key agreement protocol consists of a number of phases that
need to be executed by each party involved in the key agreement.

</p><p> To execute the next phase in the key agreement, call the
<code>doPhase</code> method:

</p><pre>    public Key doPhase(Key key, boolean lastPhase);
</pre>

<p> The <code>key</code> parameter contains the key to be processed by
that phase. In most cases, this is the public key of one of the other
parties involved in the key agreement, or an intermediate key that was
generated by a previous phase. <code>doPhase</code> may return an
intermediate key that you may have to send to the other parties of
this key agreement, so they can process it in a subsequent phase.

</p><p> The <code>lastPhase</code> parameter specifies whether or not the phase to
be executed is the last one in the key agreeement: A value of
<code>FALSE</code> indicates that this is not the last phase of the
key agreement (there are more phases to follow), and a value of
<code>TRUE</code> indicates that this is the last phase of the key
agreement and the key agreement is completed, i.e.,
<code>generateSecret</code> can be called next.

</p><p> In the example of Diffie-Hellman between two parties (see
<a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppF">Appendix F</a>), you call
<code>doPhase</code> once, with <code>lastPhase</code>
set to <code>TRUE</code>. In the example of Diffie-Hellman between three
parties, you call <code>doPhase</code> twice: the first time with
<code>lastPhase</code> set to <code>FALSE</code>, the 2nd time with
<code>lastPhase</code> set to <code>TRUE</code>.

</p></blockquote>

<h4>Generating the Shared Secret</h4>

<blockquote>

<p> After each party has executed all the required key agreement
phases, it can compute the shared secret by calling one of the
<code>generateSecret</code> methods:

</p><pre>    public byte[] generateSecret();

    public int generateSecret(byte[] sharedSecret, int offset);

    public SecretKey generateSecret(String algorithm);
</pre>

</blockquote>

</blockquote>

</li><li><h2><a name="Mac">The Mac Class</a></h2>

<blockquote>

<p> The Mac class provides the functionality of a Message
Authentication Code (MAC). Please refer to the <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#HmacEx">code
example</a> in Appendix F.

</p><h4>Creating a Mac Object</h4>

<blockquote>

<p> Like other engine classes in the API,
Mac objects are created using the <code>getInstance</code>
factory methods of the Mac class.  A factory method is a
static method that returns an instance of a class, in this case, an
instance of <code>Mac</code> which provides the requested MAC
algorithm.

</p><p><code>getInstance</code> takes as its argument the name of a MAC
algorithm. Optionally, a package provider name may be specified:

</p><pre>    public static Mac getInstance(String algorithm);

    public static Mac getInstance(String algorithm,
                                  String provider);
</pre>

<p> If just an algorithm name is specified, the system will determine
if there is an implementation of the requested MAC algorithm available
in the environment, and if there is more than one, if there is a
preferred one.

</p><p> If both an algorithm name and a package provider are specified,
the system will determine if there is an implementation of the
requested MAC algorithm in the package requested, and throw an
exception if there is not.

</p></blockquote>

<h4>Initializing a Mac Object</h4>

<blockquote>

<p> A Mac object is always initialized with a (secret) key and may
optionally be initialized with a set of parameters, depending on the
underlying MAC algorithm.

</p><p> To initialize a Mac object, call one of its <code>init</code>
methods:

</p><pre>    public void init(Key key);

    public void init(Key key, AlgorithmParameterSpec params);
</pre>

<p> You can initialize your Mac object with any (secret-)key object
that implements the <code>javax.crypto.SecretKey</code>
interface. This could be an object returned by
<code>javax.crypto.KeyGenerator.generateKey()</code>, or one that is
the result of a key agreement protocol, as returned by
<code>javax.crypto.KeyAgreement.generateSecret()</code>, or an
instance of <code>javax.crypto.spec.SecretKeySpec</code>.

</p><p> With some MAC algorithms, the (secret-)key algorithm associated
with the (secret-)key object used to initialize the Mac object does
not matter (this is the case with the HMAC-MD5 and HMAC-SHA1
implementations of the SunJCE provider). With others, however, the
(secret-)key algorithm does matter, and an
<code>InvalidKeyException</code> is thrown if a (secret-)key object
with an inappropriate (secret-)key algorithm is used.

</p></blockquote>

<h4>Computing a MAC</h4>

<blockquote>

<p> A MAC can be computed in one step (<i>single-part
operation</i>) or in multiple steps (<i>multiple-part
operation</i>). A multiple-part operation is useful if you do not know
in advance how long the data is going to be, or if the data is too
long to be stored in memory all at once.

</p><p> To compute the MAC of some data in a single step, call the
following <code>doFinal</code> method:

</p><pre>    public byte[] doFinal(byte[] input);
</pre>

<p> To compute the MAC of some data in multiple steps, call one of the
<code>update</code> methods:

</p><pre>    public void update(byte input);

    public void update(byte[] input);

    public void update(byte[] input, int inputOffset, int inputLen);
</pre>

<p> A multiple-part operation must be terminated by the above
<code>doFinal</code> method (if there is still some input data left
for the last step), or by one of the following <code>doFinal</code>
methods (if there is no input data left for the last step):

</p><pre>    public byte[] doFinal();

    public void doFinal(byte[] output, int outOffset);
</pre>

</blockquote>

</blockquote>

</li></ul>

</blockquote>

<br>



<h1><a name="ExemptApps">How to Make Applications "Exempt" from Cryptographic 
Restrictions</a></h1>

<blockquote>

<blockquote>
<font color="red"><i>[Note 1: This section should be ignored by most application
developers. It is only for people whose applications may be exported to
those few countries whose governments mandate cryptographic restrictions,
if it desired that such applications have fewer cryptographic restrictions 
than those mandated. If you want to skip this section, you can go on
to <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#InstallProvider">Installing JCE Providers for 
the Java 2 SDK, v 1.4</a>.]</i></font><p> 
</p></blockquote>

<blockquote>
<font color="red"><i>[Note 2: Throughout this section,
the term "application" is meant to encompass both 
applications and applets.]</i>
</font><p> 
</p></blockquote>
 

<p> The JCE framework within the Java 2 SDK, v 1.4 includes an ability to 
enforce restrictions regarding the cryptographic 
algorithms and maximum cryptographic strengths available to
applets/applications in different jurisdiction contexts (locations).
Any such restrictions are specified in "jurisdiction policy files". 

</p><p>Due to import control restrictions by the governments of a few
countries, the jurisdiction policy files shipped with the Java 2 SDK, v 1.4 from 
Sun Microsystems specify that "strong" but limited cryptography may be used. 
An "unlimited strength" version of these files indicating no restrictions on
cryptographic strengths is available for those living in
eligible countries (which is most countries). But only the
"strong" version can be imported into those countries whose
governments mandate restrictions.
The JCE framework will enforce the restrictions specified in
the installed jurisdiction policy files.

</p><p> It is possible that the governments of some or all such countries
may allow certain applications to become exempt from some or all 
cryptographic restrictions. For example, they may
consider certain types of applications as "special" and thus exempt.
Or they may exempt any application that 
utilizes an "exemption mechanism," such as key recovery.
Applications deemed to be exempt could get access to stronger
cryptography than that allowed for non-exempt applications
in such countries.

</p><p> In order for an application to be recognized as "exempt" at runtime,
it must meet the following conditions:

</p><ul>
<li>It must have a permission policy file bundled with it in a JAR file.
The permission policy file specifies what cryptography-related permissions
the application has, and under what conditions (if any).<p> 
</p></li><li>The JAR file containing the application and the 
permission policy file must have been
signed using a code-signing certificate issued after the application 
was accepted as exempt.
</li></ul>

<p> Below are sample steps required in order to make an application exempt from
some or all cryptographic restrictions. This is a basic outline that
includes information about what is required by JCE in order to
recognize and treat applications as being exempt. You will need to know
the exemption requirements of the particular country or countries in which you
would like your application to be able to be run but whose governments
require cryptographic restrictions. You will also need to know the
requirements of a JCE framework vendor that has a process
in place for handling exempt applications. Consult such a vendor for
further information. (Note: The SunJCE provider does not supply an
implementation of the ExemptionMechanismSpi class.)

</p><p>

</p><ul>

<li>Step 1: Write and Compile Your Application Code<p>

</p></li><li>Step 2: Create a Permission Policy File 
Granting Appropriate Cryptographic Permissions<p>

</p></li><li>Step 3: Prepare for Testing<p>

</p><blockquote>

    <li>Step 3a: Apply for Government Approval
From the Government Mandating Restrictions.<p>

    </p></li><li>Step 3b: Get a Code-Signing Certificate<p>

    </p></li><li>Step 3c: Bundle the Application and 
Permission Policy File into a JAR file<p>

    </p></li><li>Step 3d: Sign the JAR file<p>

    </p></li><li>Step 3e: Set Up Your Environment Like That of a
User in a Restricted Country<p>

    </p></li><li>Step 3f: (only for apps using exemption
mechanisms) Install a Provider Implementing the Exemption Mechanism
Specified in the Permission Policy File<p>

</p></li></blockquote>


</li><li>Step 4: Test Your Application<p>

</p></li><li>Step 5: Apply for U.S. Government Export Approval If Required
<p>

</p></li><li>Step 6: Deploy Your Application<p>

</p></li></ul>

<br> 



<h2>Special Code Requirements for Applications that Use Exemption Mechanisms</h2>

<blockquote>

<p> When an application has a permission policy file associated with it 
(in the same JAR file) and that permission policy file specifies 
an exemption mechanism, then when the
Cipher <code>getInstance</code> method is called to instantiate a Cipher, the
JCE code searches the installed providers for one that
implements the specified exemption mechanism. If it finds such a
provider, JCE instantiates an ExemptionMechanism API object 
associated with the provider's implementation, and then
associates the ExemptionMechanism object with the Cipher returned by
<code>getInstance</code>.

</p><p> After instantiating a Cipher, and prior to initializing it 
(via a call to the Cipher <code>init</code> method), your code must 
call the following Cipher method:

</p><pre>    public ExemptionMechanism getExemptionMechanism()
</pre>

<p> This call returns the ExemptionMechanism object associated with the
Cipher. You must then initialize the exemption mechanism implementation
by calling the following method on the returned ExemptionMechanism:

</p><pre>     public final void init(Key key)
</pre>

<p> The argument you supply should be the same as the argument of
the same types that you will subsequently supply to a Cipher 
<code>init</code> method.

</p><p> Once you have initialized the ExemptionMechanism, you can
proceed as usual to initialize and use the Cipher.

</p></blockquote>



<h2>Permission Policy Files </h2>

<blockquote>

<p> In order for an application to be recognized at runtime
as being "exempt" from some or all cryptographic restrictions,
it must have a permission policy file bundled with it in a JAR file.
The permission policy file specifies what cryptography-related permissions
the application has, and under what conditions (if any).

</p><p> <font color="red"><i>Note: The permission policy file bundled 
with an application 
must be named <b><code>cryptoPerms</code></b>.</i></font>

</p><p> The format of a permission entry in a permission policy file that
accompanies an exempt application is the same as the format for
a jurisdiction policy file downloaded with the Java 2 SDK, v 1.4, which is:

</p><blockquote>
<pre>permission &lt;crypto permission class name&gt;[ &lt;alg_name&gt;
    [[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt;
    [, &lt;AlgorithmParameterSpec class name&gt;,
    &lt;parameters for constructing an AlgorithmParameterSpec object&gt;]]]];
</pre>
</blockquote>

<p> See <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppD">Appendix D</a> for more information about the 
jurisdiction policy file format.


</p><h3>Permission Policy Files for Exempt Applications</h3>

<blockquote>

<p> Some applications may be allowed to be completely
unrestricted. Thus, the permission policy file that accompanies such an
application usually just needs to contain
the following:

</p><blockquote>
<pre>grant {
    // There are no restrictions to any algorithms.
    permission javax.crypto.CryptoAllPermission;
};
</pre>
</blockquote>

<p> If an application just uses a single algorithm (or several
specific algorithms), then the permission policy file could simply mention 
that algorithm (or algorithms) explicitly, rather than
granting CryptoAllPermission. For example, if
an application just uses the Blowfish algorithm, the permission policy file 
doesn't have to grant CryptoAllPermission to all algorithms. It could
just specify that there is no cryptographic restriction if the Blowfish
algorithm is used. In order to do this,
the permission policy file would look like the following: 

</p><blockquote>
<pre>grant {
    permission javax.crypto.CryptoPermission "Blowfish";
};
</pre>
</blockquote>


</blockquote>


<h3>Permission Policy Files for Applications Exempt Due to 
Exemption Mechanisms</h3>

<blockquote>

<p> If an application is considered "exempt" if 
an exemption mechanism is enforced, then the permission
policy file that accompanies the
application must specify one or more exemption mechanisms.
At runtime, the application will be considered exempt if
any of those exemption mechanisms is enforced.
Each exemption mechanism must be specified in a permission
entry that looks like the following:

</p><blockquote>
<pre>    // No algorithm restrictions if specified
    // exemption mechanism is enforced.
    permission javax.crypto.CryptoPermission *, 
        "&lt;ExemptionMechanismName&gt;";
</pre>
</blockquote>

<p> where <code>&lt;ExemptionMechanismName&gt;</code> specifies the name of an
exemption mechanism. The list of possible exemption mechanism names includes:

</p><ul>
<li>KeyRecovery<p> 
</p></li><li>KeyEscrow<p> 
</p></li><li>KeyWeakening
</li></ul>

As an example, suppose your application is exempt if either key recovery 
or key escrow is enforced.
Then your permission policy file should contain the following:

<blockquote>
<pre>grant {
    // No algorithm restrictions if KeyRecovery is enforced.
    permission javax.crypto.CryptoPermission *, 
        "KeyRecovery";
    // No algorithm restrictions if KeyEscrow is enforced.
    permission javax.crypto.CryptoPermission *, 
        "KeyEscrow";
};
</pre>
</blockquote>

<p> Note: Permission entries that specify exemption mechanisms 
should <i>not</i> also specify maximum key sizes. The allowed key sizes 
are actually determined from the installed exempt jurisdiction policy files, 
as described in the next section.
 
</p></blockquote>


<h3>How Bundled Permission Policy Files Affect Cryptographic Permissions</h3>

<blockquote>

<p> At runtime, when an application instantiates a Cipher (via a
call to its <code>getInstance</code> method) and that
application has an associated permission policy file, JCE 
checks to see whether the permission policy file has an entry that applies
to the algorithm specified in the <code>getInstance</code> call.
If it does, and the entry grants CryptoAllPermission or 
does not specify that an exemption mechanism must be enforced, 
it means there is no cryptographic restriction
for this particular algorithm.

</p><p> If the permission policy file has an entry that applies
to the algorithm specified in the <code>getInstance</code> call
and the entry <i>does</i> specify that an
exemption mechanism must be enforced, 
then the exempt jurisdiction policy file(s) are examined.
If the exempt permissions include an entry
for the relevant algorithm and exemption mechanism,
and that entry is implied by the permissions in the
permission policy file bundled with the application, 
and if there is an implementation of the specified
exemption mechanism available from one of the registered
providers, then the maximum key size and algorithm parameter
values for the Cipher are determined from the
exempt permission entry.

</p><p> If there is no exempt permission entry implied by
the relevant entry in the permission policy file bundled with the application,
or if there is no implementation of the specified
exemption mechanism available from any of the registered
providers, then the application is only allowed the standard
default cryptographic permissions.

</p></blockquote>

</blockquote>

</blockquote>


<br>



<h1><a name="InstallProvider">Installing JCE Providers for 
the Java 2 SDK, v 1.4</a></h1>

<blockquote>

<p> In order to be used, a cryptographic provider must be installed
and registered, either statically or dynamically. 
Cryptographic providers for JCE in the Java 2 SDK, v 1.4 are installed and 
configured the same way as all other providers for the Java<sup><font size="-2">TM</font></sup> 2 platform. More
information about installing and configuring providers can be found in
the <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/CryptoSpec.html#ProviderInstalling">Installing
Providers</a> section of the <i>Java<sup><font size="-2">TM</font></sup> Cryptography Architecture API Specification &amp; Reference</i> document.

</p><p>You do not need to register the "SunJCE" 
provider because it is pre-registered. If you want to use other
providers, read the following sections to see how to register
them.

</p><p>Installing a provider is done in two steps: 
<a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#InstallProv">installing the provider package classes</a>, 
and <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#Configuring">configuring the provider</a>.
In some situations you will also need to 
<a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#SettingPerms">set permissions</a>
for the provider prior to using it.


</p><h2><a name="InstallProv">Installing the Provider Classes</a></h2>

<blockquote>

The first thing you must do is make the provider classes available 
so that they can be found when requested. 
Provider classes are shipped as a signed JAR (Java ARchive) file.

<p>There are two possible ways to install the provider classes:
</p><ul>
<li>Install the JAR file containing the provider classes as an 
"installed" or "bundled" extension.</li>
<li>Place the JAR file containing the provider classes 
in your class path.</li>
</ul>


<p>The provider JAR file will be considered an <em>installed</em> 
extension if it is placed in 
the standard place for the JAR files of an installed extension:
</p><blockquote><pre>&lt;java-home&gt;/lib/ext         [Solaris]
&lt;java-home&gt;\lib\ext         [Windows]
</pre></blockquote>
<p>

</p><p> Here <tt>&lt;java-home&gt;</tt> refers to the directory where the 
runtime software is installed, which is the top-level directory of the 
Java<sup><font size="-2">TM</font></sup> 2 Runtime Environment (JRE)
or the <tt>jre</tt> directory in the 
Java<sup><font size="-2">TM</font></sup> 2 SDK (Java 2 SDK) software. 
For example, if you have the Java 2 SDK, v 1.4 
installed on Solaris in a directory named <code>/home/user1/Java 2 SDK1.4.0</code>,
or on Microsoft Windows in a directory named <code>C:\Java 2 SDK1.4.0</code>, then you
need to install the JAR file in the following directory:

</p><blockquote><pre>/home/user1/Java 2 SDK1.4.0/jre/lib/ext    [Solaris]
C:\Java 2 SDK1.4.0\jre\lib\ext             [Windows]
</pre></blockquote>

<p> Similarly, if you have the JRE, v 1.4 
installed on Solaris in a directory named <code>/home/user1/j2re1.4.0</code>,
or on Microsoft Windows in a directory named <code>C:\j2re1.4.0</code>, 
you need to install the JAR file in the following directory:

</p><blockquote><pre>/home/user1/j2re1.4.0/lib/ext         [Solaris]
C:\j2re1.4.0\lib\ext                  [Windows]
</pre></blockquote>

<p>For more information, refer to these sections in the "Extension Mechanism Architecture" 
specification:  
<a href="http://docs.oracle.com/javase/1.4.2/docs/guide/extensions/spec.html#installed">Installed Extensions</a> and 
<a href="http://docs.oracle.com/javase/1.4.2/docs/guide/extensions/spec.html#bundled">Bundled Extensions</a>.

</p></blockquote>


<h2><a name="Configuring">Configuring the Provider</a></h2>

<blockquote>

<p>The next step is to add the provider to your list of approved
providers. This is done statically by editing the security properties file

</p><blockquote><pre>&lt;java-home&gt;/lib/security/java.security     [Solaris]
&lt;java-home&gt;\lib\security\java.security     [Windows]
</pre></blockquote>

<p>Here <tt>&lt;java-home&gt;</tt> refers to the directory where the JRE
was installed. For example, if you have the Java 2 SDK v 1.4 
installed on Solaris in a directory named <code>/home/user1/Java 2 SDK1.4.0</code>, 
or on Microsoft Windows in a directory named <code>C:\Java 2 SDK1.4.0</code>, then you
need to edit the following file:

</p><blockquote><pre>/home/user1/Java 2 SDK1.4.0/jre/lib/security/java.security  [Solaris]
C:\Java 2 SDK1.4.0\jre\lib\security\java.security           [Windows]
</pre></blockquote>

<p>Similarly, if you have the Java 2 Runtime Environment, v 1.4
installed on Solaris in a directory named <code>/home/user1/j2re1.4.0</code>, 
or on Microsoft Windows in a directory named <code>C:\j2re1.4.0</code>, then you
need to edit this file:

</p><blockquote><pre>/home/user1/j2re1.4.0/lib/security/java.security       [Solaris]
C:\j2re1.4.0\lib\security\java.security                [Windows]
</pre></blockquote>

<p>For each provider, this file should have a statement
of the following form:

</p><pre>    security.provider.<i>n</i>=<i>masterClassName</i>
</pre>

<p>This declares a provider, and specifies its preference order
<i>n</i>. The preference order is the order in which providers are
searched for requested algorithms when no specific provider is 
requested. The order is 1-based; 1 is the most preferred, followed
by 2, and so on.

</p><p><i>masterClassName</i> must specify the fully qualified
name of the provider's "master
class". The provider vendor should supply you this name.

</p><p>The Java 2 SDK, v 1.4 comes standard with a provider named "SUN", which is
automatically configured as a static provider in the
<code>java.security</code> properties file, as follows:

</p><blockquote>
<pre>security.provider.1=sun.security.provider.Sun
</pre>
</blockquote>

<p>(The "SUN" provider's master class is the 
<code>Sun</code> class in the <code>sun.security.provider</code>
package.)

</p><p>The JCE provider "SunJCE" and other security-related providers 
shipped with the Java 2 platform are
also automatically configured as static providers.

</p><p> To utilize another JCE provider, add a line registering the
alternate provider, giving it whatever preference order you prefer
(and making corresponding adjustments to the other providers'
orders, if needed).

</p><p>Suppose that the master class of a provider you want to register
is the <code>CryptoX</code> class in the
<code>com.cryptox.provider</code> package,
and that you would like to make this provider the second
preferred provider. To do so, add the following line to the 
<code>java.security</code> file below the line for the "SUN"
provider, and increment the preference order numbers for all other
providers whose numbers were greater than or equal to 2 before
your addition:

</p><pre>    security.provider.2=com.cryptox.provider.CryptoX
</pre>

Note: Providers may also be registered dynamically. To do so, 
a program can call either the <code>addProvider</code> or
<code>insertProviderAt</code> method in the <code>Security</code> class.
This type of registration is not persistent and can only be
done by code which is granted the following permission:

<blockquote>
<pre>java.security.SecurityPermission "insertProvider.{name}"
</pre>
</blockquote>

where <code>{name}</code> is replaced by the actual provider name.
For example, if the provider name is "MyJCE" and if your
code that dynamically registers this provider 
is in the <code>MyApp.jar</code> file in the 
<code>/localWork</code> directory, then here is a sample policy file
<code>grant</code> statement granting that permission:

<blockquote>
<pre>grant codeBase "file:/localWork/MyApp.jar" {
  permission java.security.SecurityPermission
      "insertProvider.MyJCE";
};
</pre>
</blockquote>


</blockquote>


<h2><a name="SettingPerms">Setting Provider Permissions</a></h2>

<blockquote>

<p> Whenever JCE providers are not installed extensions, <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/permissions.html">
permissions</a> must be granted for when applets or applications using JCE 
are run while a security manager is installed.
There is typically a security manager installed whenever an applet is 
running, and a security manager may be installed for an application 
either via code in the application itself or via a command-line argument.
Permissions do not need to be granted to installed extensions,
since the default system 
<a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/PolicyFiles.html">policy configuration file</a>
grants all permissions to installed extensions.

</p><p> The documentation from the vendor of each provider you will
be using should include information as to which permissions it
requires, and how to grant such permissions. 
For example, the following permissions may be needed by a
provider if it is not an installed extension and a security manager
is installed:

</p><ul>
<li> <code>java.lang.RuntimePermission</code> to get class protection domains.
The provider may need to get its own protection domain in the process
of doing self-integrity checking. <p>
</p></li><li> <code>java.security.SecurityPermission "putProviderProperty.{name}"</code>
to set provider properties, where <code>{name}</code> is replaced by 
the actual provider name. 
</li></ul>

<p>For example, 
a sample statement granting permissions to a provider whose
name is "MyJCE" and whose code is in <code>myjce_provider.jar</code> appears
below. Such a statement could appear in a 
policy file. In this example, the
<code>myjce_provider.jar</code> file is assumed
to be in the <code>/localWork</code> directory.

</p><blockquote>
<pre>grant codeBase "file:/localWork/myjce_provider.jar" {
  permission java.lang.RuntimePermission "getProtectionDomain";
  permission java.security.SecurityPermission
      "putProviderProperty.MyJCE";
};
</pre>
</blockquote>


</blockquote>


</blockquote>

<br>


<h1><a name="JceKeystore">JCE Keystore</a></h1>

<blockquote>

<p> The "SunJCE" provider supplies its own implementation of the
<code>java.security.KeyStore</code> class in the Java 2 SDK, v 1.4. Its
implementation employs a much stronger protection of private keys
(using password-based encryption with Triple DES) than the keystore
implementation supplied by the "SUN" provider in the Java 2 SDK, v 1.4. (Note that
because the Java 2 SDK, v 1.4 is distributed world-wide in binary and source format,
it cannot employ any strong encryption mechanisms.)

</p><p> In order to take advantage of the keystore implementation of the
"SunJCE" provider, you specify "<i>JCEKS</i>" as the keystore type.

</p><p> You may upgrade your keystore of type "<i>JKS</i>" - this is the
name of the keystore type implemented by the "SUN" provider in 
the Java 2 SDK 
- to a JCE keystore of type "<i>JCEKS</i>" by changing the
password of a private-key entry in your keystore.

</p><p> To apply the cryptographically strong(er) key protection supplied by
"SunJCE" to a private key named "signkey" in your default keystore,
use the following command, which will prompt you for the old and new
key passwords:

</p><pre>    keytool -keypasswd -alias signkey -storetype jceks
</pre>

<p> You may want to change the password back to its old value, using
the same command.

</p><p> See <a href="http://docs.oracle.com/javase/1.4.2/docs/tooldocs/tools.html#security">Security Tools</a>
for more information about <code>keytool</code> and about keystores and 
how they are managed.

</p></blockquote>

<br>



<h1><a name="Examples">Code Examples</a></h1>

<blockquote>

<p> This section is a short tutorial on how to use some of the major
features of the JCE APIs in the Java 2 SDK, v 1.4. Complete sample programs 
that exercise the APIs can be found in <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppF">Appendix F</a> 
of this document.

</p><h2><a name="SimpleEncrEx">Using Encryption</a></h2>

<blockquote>

<p> This section takes the user through the process of generating a
key, creating and initializing a cipher object, encrypting a file, and
then decrypting it. Throughout this example, we use the Data
Encryption Standard (DES).

</p><h4>Generating a Key</h4>

<blockquote>

<p> To create a DES key, we have to instantiate a KeyGenerator for
DES. We do not specify a provider, because we do not care about a
particular DES key generation implementation. Since we do not
initialize the KeyGenerator, a system-provided source of randomness
will be used to create the DES key:

</p><pre>    KeyGenerator keygen = KeyGenerator.getInstance("DES");
    SecretKey desKey = keygen.generateKey();
</pre>

<p> After the key has been generated, the same KeyGenerator object can
be re-used to create further keys.

</p></blockquote>

<h4>Creating a Cipher</h4>

<blockquote>

<p> The next step is to create a Cipher instance. To do this, we use
one of the <code>getInstance</code> factory methods of the Cipher
class. We must specify the name of the requested transformation, which
includes the following components, separated by slashes (/):

</p><ul>
<li>the algorithm name </li><li>the mode (optional) </li><li>the padding scheme
(optional)
</li></ul>

<p> In this example, we create a DES (Data Encryption Standard) cipher
in Electronic Codebook mode, with PKCS #5-style padding. We do not
specify a provider, because we do not care about a particular
implementation of the requested transformation.

</p><p> The standard algorithm name for DES is "DES", the standard name
for the Electronic Codebook mode is "ECB", and the standard name for
PKCS #5-style padding is "PKCS5Padding":

</p><pre>    Cipher desCipher;

    // Create the cipher 
    desCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
</pre>

<p> We use the generated <code>desKey</code> from above to initialize
the Cipher object for encryption:

</p><pre>    // Initialize the cipher for encryption
    desCipher.init(Cipher.ENCRYPT_MODE, desKey);

    // Our cleartext
    byte[] cleartext = "This is just an example".getBytes();

    // Encrypt the cleartext
    byte[] ciphertext = desCipher.doFinal(cleartext);

    // Initialize the same cipher for decryption
    desCipher.init(Cipher.DECRYPT_MODE, desKey);

    // Decrypt the ciphertext
    byte[] cleartext1 = desCipher.doFinal(ciphertext);
</pre>

<p> <code>cleartext</code> and <code>cleartext1</code> are identical.

</p></blockquote>

</blockquote>

<h2><a name="PBEEx">Using Password-Based Encryption</a></h2>

<blockquote>

<p> In this example, we prompt the user for a password from which we
derive an encryption key.

</p><p> It would seem logical to collect and store the password in an
object of type <code>java.lang.String</code>. However, here's the
caveat: Objects of type <code>String</code> are immutable, i.e., there
are no methods defined that allow you to change (overwrite) or zero
out the contents of a <code>String</code> after usage. This feature
makes <code>String</code> objects unsuitable for storing security
sensitive information such as user passwords. You should always
collect and store security sensitive information in a char array
instead.

</p><p> For that reason, the <code>javax.crypto.spec.PBEKeySpec</code>
class takes (and returns) a password as a char array.

</p><p> The following method is an example of how to collect a user
password as a char array:

</p><pre>    /**
     * Reads user password from given input stream.
     */
    public char[] readPasswd(InputStream in) throws IOException {
        char[] lineBuffer;
        char[] buf;
        int i;

        buf = lineBuffer = new char[128];

        int room = buf.length;
        int offset = 0;
        int c;

loop:   while (true) {
            switch (c = in.read()) {
              case -1: 
              case '\n':
                break loop;

              case '\r':
                int c2 = in.read();
                if ((c2 != '\n') &amp;&amp; (c2 != -1)) {
                    if (!(in instanceof PushbackInputStream)) {
                        in = new PushbackInputStream(in);
                    }
                    ((PushbackInputStream)in).unread(c2);
                } else 
                    break loop;

              default:
                if (--room &lt; 0) {
                    buf = new char[offset + 128];
                    room = buf.length - offset - 1;
                    System.arraycopy(lineBuffer, 0, buf, 0, offset);
                    Arrays.fill(lineBuffer, ' ');
                    lineBuffer = buf;
                }
                buf[offset++] = (char) c;
                break;
            }
        }

        if (offset == 0) {
            return null;
        }

        char[] ret = new char[offset];
        System.arraycopy(buf, 0, ret, 0, offset);
        Arrays.fill(buf, ' ');

        return ret;
    }
</pre>

<p> In order to use Password-Based Encryption (PBE) as defined in
PKCS #5, we have to specify a <i>salt</i> and an <i>iteration
count</i>. The same salt and iteration count that are used for
encryption must be used for decryption:

</p><pre>    PBEKeySpec pbeKeySpec;
    PBEParameterSpec pbeParamSpec;
    SecretKeyFactory keyFac;

    // Salt
    byte[] salt = {
        (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,
        (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99
    };

    // Iteration count
    int count = 20;

    // Create PBE parameter set
    pbeParamSpec = new PBEParameterSpec(salt, count);

    // Prompt user for encryption password.
    // Collect user password as char array (using the
    // "readPasswd" method from above), and convert
    // it into a SecretKey object, using a PBE key
    // factory.
    System.out.print("Enter encryption password:  ");
    System.out.flush();
    pbeKeySpec = new PBEKeySpec(readPasswd(System.in));
    keyFac = SecretKeyFactory.getInstance("PBEWithMD5AndDES");
    SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);

    // Create PBE Cipher
    Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES");

    // Initialize PBE Cipher with key and parameters
    pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);

    // Our cleartext
    byte[] cleartext = "This is another example".getBytes();

    // Encrypt the cleartext
    byte[] ciphertext = pbeCipher.doFinal(cleartext);
</pre>

</blockquote>

<h2><a name="KeyAgreeEx">Using Key Agreement</a></h2>

<blockquote>

<p> Please refer to <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppF">Appendix F</a> for sample programs
exercising the Diffie-Hellman key exchange between 2 and 3 parties,
respectively.

</p></blockquote>

</blockquote>

<hr>

<h1><a name="AppA">Appendix A: Standard Names</a></h1>

<blockquote>

<p> The JCE API requires and utilizes a set of standard names for
algorithms, algorithm modes, and padding schemes.
This specification establishes the following names as standard names. It
supplements the list of standard names defined in <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/CryptoSpec.html#AppA">Appendix
A</a> in the <i>Java<sup><font size="-2">TM</font></sup> Cryptography Architecture API Specification &amp; Reference</i>. Note that algorithm names are treated case-insensitively.

</p><p>In some cases naming conventions are suggested for forming names that 
are not explicitly listed, to facilitate name consistency across
provider implementations. 
Such suggestions use items in angle brackets
(such as &lt;digest&gt; and &lt;encryption&gt;)
as placeholders to be replaced by specific message digest, encryption algorithm, 
and other names.

</p><h2>Cipher</h2>

<blockquote>

<h4>Algorithm</h4>

<blockquote>

<p>
The following names can be specified as the <i>algorithm</i>
component in a <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#trans">transformation</a> when
requesting an instance of <code><big><b>Cipher</b></big></code>:</p><p>
</p><ul>
<li><b>AES</b>: Advanced Encryption Standard as specified by NIST in a 
draft FIPS. Based on the Rijndael algorithm by Joan Daemen and Vincent 
Rijmen, AES is a 128-bit block cipher supporting keys of 128, 192, and 
256 bits.
<p>
</p></li><li><b>Blowfish</b>: The block cipher designed by Bruce Schneier.
<p>
</p></li><li><b>DES</b>: The Digital Encryption Standard as described in FIPS PUB 46-2.
<p>
</p></li><li><b>DESede</b>: Triple DES Encryption (DES-EDE).
<p>
</p></li><li><b>PBEWith&lt;digest&gt;And&lt;encryption&gt;</b> or
<b>PBEWith&lt;prf&gt;And&lt;encryption&gt;</b>: The password-based encryption 
algorithm (PKCS #5), using the specified message digest (&lt;digest&gt;) 
or pseudo-random function (&lt;prf&gt;) and encryption algorithm
(&lt;encryption&gt;). Examples: <p>

</p><ul>
<li><b>PBEWithMD5AndDES</b>: The password-based encryption algorithm
as defined in: RSA Laboratories, "PKCS #5: Password-Based Encryption
Standard," version 1.5, Nov 1993. Note that this algorithm implies <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#cbcMode"><i>CBC</i></a> as the cipher mode and <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#pkcs5Pad"><i>PKCS5Padding</i></a> as the padding scheme and
cannot be used with any other cipher modes or padding schemes. <p>

</p></li><li><b>PBEWithHmacSHA1AndDESede</b>: The password-based encryption algorithm as
defined in: RSA Laboratories, "PKCS #5: Password-Based Cryptography
Standard," version 2.0, March 1999.

</li></ul>

<p>
</p></li><li><b>RC2</b>, <b>RC4</b>, and <b>RC5</b>: Variable-key-size 
encryption algorithms developed by Ron Rivest for RSA Data Security, Inc.
<p>
</p></li><li><b>RSA</b>: The RSA encryption algorithm as defined in PKCS #1.
</li></ul>

</blockquote>

<h4>Mode</h4>

<blockquote>

<p>
The following names can be specified as the <i>mode</i>
component in a <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#trans">transformation</a> when
requesting an instance of <code><big><b>Cipher</b></big></code>:</p><p>
</p><ul>
<li><b>NONE</b>: No mode.
<p>
</p></li><li><b><a name="cbcMode">CBC</a></b>: Cipher Block Chaining Mode, as
defined in FIPS PUB 81.
<p>
</p></li><li><b>CFB</b>: Cipher Feedback Mode, as defined in FIPS PUB 81.
<p>
</p></li><li><b>ECB</b>: Electronic Codebook Mode, as defined in: The National
Institute of Standards and Technology (NIST) Federal Information
Processing Standard (FIPS) PUB 81, "DES Modes of Operation,"
U.S. Department of Commerce, Dec 1980.
<p>
</p></li><li><b>OFB</b>: Output Feedback Mode, as defined in FIPS PUB 81.
<p>
</p></li><li><b>PCBC</b>: Propagating Cipher Block Chaining, as defined by Kerberos V4.
</li></ul>

</blockquote>

<h4>Padding</h4>

<blockquote>

<p>
The following names can be specified as the <i>padding</i>
component in a <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#trans">transformation</a> when
requesting an instance of <code><big><b>Cipher</b></big></code>:</p><p>
</p><ul>
<li><b>NoPadding</b>: No padding.
<p>
</p></li><li><b>OAEPWith&lt;digest&gt;And&lt;mgf&gt;Padding</b>: Optimal
Asymmetric Encryption Padding scheme defined in PKCS #1,
where &lt;digest&gt; should be replaced by
the message digest and &lt;mgf&gt; by the mask generation function.
Example: OAEPWithMD5AndMGF1Padding.
<p>
</p></li><li><b><a name="pkcs5Pad">PKCS5Padding</a></b>: The padding scheme
described in: RSA Laboratories, "PKCS #5: Password-Based Encryption
Standard," version 1.5, November 1993.
<p>
</p></li><li><b>SSL3Padding</b>: The padding scheme defined in the SSL Protocol
Version 3.0, November 18, 1996, section 5.2.3.2 (CBC block cipher):

<pre>    block-ciphered struct {
        opaque content[SSLCompressed.length];
        opaque MAC[CipherSpec.hash_size];
        uint8 padding[GenericBlockCipher.padding_length];
        uint8 padding_length;
    } GenericBlockCipher;
</pre>

<p> The size of an instance of a GenericBlockCipher must be a multiple of
the block cipher's block length.

</p><p> The padding length, which is always present, contributes to the
padding, which implies that if:

</p><pre>    sizeof(content) + sizeof(MAC) % block_length = 0,
</pre>

padding has to be (block_length - 1) bytes long, because of the existence of
<code>padding_length</code>.

<p> This make the padding scheme similar (but not quite) to PKCS5Padding, where
the padding length is encoded in the padding (and ranges from 1 to
block_length). With the SSL scheme, the sizeof(padding) is encoded in
the always present <code>padding_length</code> and therefore ranges from 0 to
block_length-1.

</p><p> Note that this padding mechanism is not supported by the "SunJCE" provider.


</p></li></ul>

</blockquote>

</blockquote>

<h2>KeyAgreement</h2>

<blockquote>

<p>
The following algorithm names can be specified when
requesting an instance of <code><big><b>KeyAgreement</b></big></code>:
</p><p>
</p><ul>
<li><b>DiffieHellman</b>: Diffie-Hellman Key Agreement as defined in PKCS #3:
Diffie-Hellman Key-Agreement Standard, RSA Laboratories, version 1.4,
November 1993.
</li></ul>

</blockquote>

<h2>KeyGenerator</h2>

<blockquote>

<p>
The following algorithm names can be specified when
requesting an instance of <code><big><b>KeyGenerator</b></big></code>:
</p><p>
</p><ul>
<li><b>AES</b>
<p>
</p></li><li><b>Blowfish</b>
<p>
</p></li><li><b>DES</b>
<p>
</p></li><li><b>DESede</b>
<p>
</p></li><li><b>HmacMD5</b>
<p>
</p></li><li><b>HmacSHA1</b>
</li></ul>

</blockquote>

<h2>KeyPairGenerator</h2>

<blockquote>

<p>
The following algorithm names can be specified when
requesting an instance of <code><big><b>KeyPairGenerator</b></big></code>:
</p><p>
</p><ul>
<li><b>DiffieHellman</b>
</li></ul>

</blockquote>

<h2>SecretKeyFactory</h2>

<blockquote>

<p>
The following algorithm names can be specified when
requesting an instance of <code><big><b>SecretKeyFactory</b></big></code>:
</p><p>
</p><ul>
<li><b>AES</b>
<p>
</p></li><li><b>DES</b>
<p>
</p></li><li><b>DESede</b>
<p>
</p></li><li><b>PBEWith&lt;digest&gt;And&lt;encryption&gt;</b> or
<b>PBEWith&lt;prf&gt;And&lt;encryption&gt;</b>: Secret-key factory 
for use with PKCS #5 password-based encryption, where &lt;digest&gt;
is a message digest, &lt;prf&gt; is a pseudo-random function, and
&lt;encryption&gt; is an encryption algorithm. Examples:
<b>PBEWithMD5AndDES</b> (PKCS #5, v 1.5) and <b>PBEWithHmacSHA1AndDESede</b>
(PKCS #5, v 2.0).
Note: These both use only the low order 8 bits of 
each password character.
</li></ul>

</blockquote>

<h2>KeyFactory</h2>

<blockquote>

<p>
The following algorithm names can be specified when
requesting an instance of <code><big><b>KeyFactory</b></big></code>:
</p><p>
</p><ul>
<li><b>DiffieHellman</b>
</li></ul>

</blockquote>

<h2>AlgorithmParameterGenerator</h2>

<blockquote>

<p>
The following algorithm names can be specified when requesting an
instance of
<code><big><b>AlgorithmParameterGenerator</b></big></code>:
</p><p>
</p><ul>
<li><b>DiffieHellman</b>
</li></ul>

</blockquote>

<h2>AlgorithmParameters</h2>

<blockquote>

<p>
The following algorithm names can be specified when requesting an
instance of <code><big><b>AlgorithmParameters</b></big></code>:
</p><p>
</p><ul>
<li><b>Blowfish</b>
<p>
</p></li><li><b>DES</b>
<p>
</p></li><li><b>DESede</b>
<p>
</p></li><li><b>DiffieHellman</b>
<p>
</p></li><li><b>PBE</b>
</li></ul>

</blockquote>

<h2>MAC</h2>

<blockquote>

<p>
The following algorithm names can be specified when
requesting an instance of <code><big><b>Mac</b></big></code>:
</p><p>
</p><ul>
<li><b>HmacMD5</b>: The HMAC-MD5 keyed-hashing algorithm as defined
in RFC 2104: "HMAC: Keyed-Hashing for Message Authentication"
(February 1997).
<p>
</p></li><li><b>HmacSHA1</b>: The HMAC-SHA1 keyed-hashing algorithm as defined
in RFC 2104: "HMAC: Keyed-Hashing for Message Authentication"
(February 1997).
<p>
</p></li><li><b>PBEWith&lt;mac&gt;</b>: MAC 
for use with PKCS #5 v 2.0 password-based message authentication standard, 
where &lt;mac&gt; is a Message Authentication Code algorithm name.
Example: PBEWithHmacSHA1.
</li></ul>

</blockquote>

<h2>Keystore Types</h2>

<blockquote>

<p>
The following types can be specified when
requesting an instance of <code><big><b>KeyStore</b></big></code>:
</p><p>
</p><ul>
<li><b>JCEKS</b>: The <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#JceKeystore">proprietary keystore type</a>
implemented by the "SunJCE" provider.
</li></ul>

</blockquote>


<h2>Exemption Mechanisms</h2>

<blockquote>

<p>
The following exemption mechanism names can be specified in the permission
policy file that accompanies an application considered "exempt" 
from cryptographic restrictions:
</p><p>
</p><ul>

<li><b>KeyEscrow</b>: An encryption system with a backup decryption capability
that allows authorized persons (users, officers of an organization, and
government officials), under certain prescribed conditions, to decrypt
ciphertext with the help of information supplied by one or more trusted
parties who hold special data recovery keys.<p>

</p></li><li><b>KeyRecovery</b>: A method of obtaining the secret key used to lock 
encrypted data. One use is as a means of providing fail-safe access to a 
corporation's own encrypted information in times of disaster.<p>

</p></li><li><b>KeyWeakening</b>: A method in which a part of the key
can be escrowed or recovered. 

</li></ul>

</blockquote>


</blockquote>

<hr>


<h1><a name="AppB">Appendix B: SunJCE Default Keysizes</a></h1>

<blockquote>

<p>
The SunJCE provider uses the following default keysizes:

</p><ul>
<li><b>KeyGenerator</b>
<p>
</p><ul>
<li><b>DES</b>: 56 bits<p>
</p></li><li><b>Triple DES</b>: 112 bits<p>
</p></li><li><b>Blowfish</b>: 56 bits<p>
</p></li><li><b>HmacMD5</b>: 64 bytes<p>
</p></li><li><b>HmacSHA1</b>: 64 bytes
</li></ul>
<p>
</p></li><li><b>KeyPairGenerator</b>
<p>
</p><ul>
<li><b>Diffie-Hellman</b>: 1024 bits
</li></ul>
<p>
</p></li><li><b>AlgorithmParameterGenerator</b>
<p>
</p><ul>
<li><b>Diffie-Hellman</b>: 1024 bits
</li></ul>
</li></ul>

</blockquote>

<hr>

<h1><a name="AppC">Appendix C: SunJCE Keysize Restrictions</a></h1>

<blockquote>

<p>
The SunJCE provider enforces the following restrictions on the
keysize passed to the initialization methods of the following classes:

</p><ul>
<li><b>KeyGenerator</b>
<p>
Restrictions (by algorithm):
</p><p>
</p><ul>
<li><b>DES</b>: keysize must be equal to <code>56</code><p>
</p></li><li><b>Triple DES</b>: keysize must be equal to
<code>112</code> or <code>168</code>
<p> Note: A keysize of <code>112</code> will generate a Triple DES key
with 2 intermediate keys, and a keysize of <code>168</code> will
generate a Triple DES key with 3 intermediate keys.</p><p>
</p></li><li><b>Blowfish</b>: keysize must be a multiple of
<code>8</code>, and can only range from <code>32</code> to
<code>448</code>, inclusive
</li></ul>
<p>
</p></li><li><b>KeyPairGenerator</b>
<p>
Restrictions (by algorithm):
</p><p>
</p><ul>
<li><b>Diffie-Hellman</b>: keysize must be a multiple of
<code>64</code>, and can only range from <code>512</code> to
<code>1024</code>, inclusive
</li></ul>
<p>
</p></li><li><b>AlgorithmParameterGenerator</b>
<p>
Restrictions (by algorithm):
</p><p>
</p><ul>
<li><b>Diffie-Hellman</b>: keysize must be a multiple of
<code>64</code>, and can only range from <code>512</code> to
<code>1024</code>, inclusive
</li></ul>
</li></ul>

</blockquote>

<hr>


<h1><a name="AppD">Appendix D: Jurisdiction Policy File Format</a></h1>

<blockquote>

<p> JCE represents its jurisdiction policy files as 
J2SE-style policy files with corresponding permission statements.
As described in <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/PolicyFiles.html">
Default Policy Implementation and Policy File Syntax</a>,
a J2SE policy file specifies what permissions are allowed for
code from specified code sources. 
A permission represents access to a system resource.
In the case of JCE, the "resources" are cryptography 
algorithms, and code sources do not need to be specified,
because the cryptographic restrictions apply to all code.

</p><p> A jurisdiction policy file consists of a very basic
"grant entry" containing one or more "permission entries."

</p><blockquote>
<pre>grant {
    &lt;permission entries&gt;;
};
</pre>
</blockquote>

<p> The format of a permission entry in a jurisdiction policy file is:

</p><blockquote>
<pre>permission &lt;crypto permission class name&gt;[ &lt;alg_name&gt;
    [[, &lt;exemption mechanism name&gt;][, &lt;maxKeySize&gt;
    [, &lt;AlgorithmParameterSpec class name&gt;,
    &lt;parameters for constructing an 
        AlgorithmParameterSpec object&gt;]]]];
</pre>
</blockquote>

<p> A sample jurisdiction policy file that includes restricting the "Blowfish"
algorithm to maximum key sizes of 64 bits is:

</p><blockquote>
<pre>grant {
    permission javax.crypto.CryptoPermission "Blowfish", 64;
    . . .;
};
</pre>
</blockquote>

<p> A permission entry must begin with the word 
<code>permission</code>. 
The <code>&lt;crypto permission class name&gt;</code> in the template above 
would actually be a specific permission class name, such as
<code>javax.crypto.CryptoPermission</code>.
A crypto permission class reflects the
ability of an application/applet to use certain algorithms with
certain key sizes in certain environments.
There are two crypto permission classes: 
<code>CryptoPermission</code> and <code>CryptoAllPermission</code>.
The special <code>CryptoAllPermission</code> class implies all
cryptography-related permissions, that is, it specifies that there are
no cryptography-related restrictions. 

</p><p> The &lt;alg_name&gt;, when utilized, is a quoted string
specifying the standard name (see <a href="http://docs.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html#AppA">Appendix A</a>) 
of a cryptography algorithm, such as "DES" or
"RSA".

</p><p> The &lt;exemption mechanism name&gt;, when specified, is
a quoted string indicating an exemption mechanism which, if
enforced, enables a reduction in cryptographic restrictions.
Exemption mechanism names that can be used include "KeyRecovery" 
"KeyEscrow", and "KeyWeakening".

</p><p> &lt;maxKeySize&gt; is an integer specifying the maximum
key size (in bits) allowed for the specified algorithm.

</p><p> For some algorithms it may not be sufficient to specify
the algorithm strength in terms of just a key size. For example,
in the case of the "RC5" algorithm, the number of rounds must
also be considered. For algorithms whose strength needs to be
expressed as more than a key size, the permission entry should
also specify an AlgorithmParameterSpec class name 
(such as <code>javax.crypto.spec.RC5ParameterSpec</code>) and a
list of parameters for constructing the specified 
AlgorithmParameterSpec object.

</p><p>Items that appear in a permission entry must appear in the specified 
order. An entry is terminated with a semicolon.

</p><p>Case is unimportant for the identifiers (<code>grant</code>, 
<code>permission</code>) but is 
significant for the <code>&lt;crypto permission class name&gt;</code>
or for any string that is passed in as a value. 

</p><p> Note: An "*" can be used as a wildcard for any permission entry
option. For example, an "*" 
(without the quotes) for an &lt;alg_name&gt; option means "all algorithms."
 

</p></blockquote>



<hr>


<h1><a name="AppE">Appendix E: Maximum Key Sizes Allowed by "Strong"
Jurisdiction Policy Files</a></h1>

<blockquote>

<p>Due to import control restrictions, the jurisdiction policy files 
shipped with the Java 2 SDK, v 1.4 allow "strong" but limited cryptography
to be used. Here are the maximum key sizes allowed by this "strong"
version of the jurisdiction policy files:

</p><p>


<table summary="maximum key sizes">
<tbody><tr>
<th rowspan="1" colspan="1">
<p class="CellHeading">
Algorithm
</p></th>
<th rowspan="1" colspan="1">
<p class="CellHeading">
Maximum Key Size
</p></th>

</tr><tr>
<td rowspan="1" colspan="1" align="CENTER">
<p>DES
</p></td>
<td rowspan="1" colspan="1" align="CENTER">
<p>64
</p></td>
</tr>

<tr>
<td rowspan="1" colspan="1" align="CENTER">
<p>DESede 
</p></td>
<td rowspan="1" colspan="1" align="CENTER">
<p>*
</p></td>
</tr>

<tr>
<td rowspan="1" colspan="1" align="CENTER">
<p>RC2
</p></td>
<td rowspan="1" colspan="1" align="CENTER">
<p>128
</p></td>
</tr>

<tr>
<td rowspan="1" colspan="1" align="CENTER">
<p>RC4
</p></td>
<td rowspan="1" colspan="1" align="CENTER">
<p>128
</p></td>
</tr>

<tr>
<td rowspan="1" colspan="1" align="CENTER">
<p>RC5
</p></td>
<td rowspan="1" colspan="1" align="CENTER">
<p>128
</p></td>
</tr>

<tr>
<td rowspan="1" colspan="1" align="CENTER">
<p>RSA
</p></td>
<td rowspan="1" colspan="1" align="CENTER">
<p>2048
</p></td>
</tr>

<tr>
<td rowspan="1" colspan="1" align="CENTER">
<p>* (all others)
</p></td>
<td rowspan="1" colspan="1" align="CENTER">
<p>128
</p></td>
</tr>

</tbody></table>



</p></blockquote>



<hr>


<h1><a name="AppF">Appendix F: Sample Programs</a></h1>

<ul>

<li><a name="DH2Ex"><h3>Diffie-Hellman Key Exchange between 2 Parties</h3></a>

<pre>/*
 * Copyright 1997-2001 by Oracle and/or its affiliates.,
 * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Oracle and/or its affiliates. ("Confidential Information").  You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Sun.
 */

import java.io.*;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.*;
import java.security.interfaces.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
import com.sun.crypto.provider.SunJCE;

/**
 * This program executes the Diffie-Hellman key agreement protocol
 * between 2 parties: Alice and Bob.
 *
 * By default, preconfigured parameters (1024-bit prime modulus and base
 * generator used by SKIP) are used.
 * If this program is called with the "-gen" option, a new set of
 * parameters is created.
 */

public class DHKeyAgreement2 {

    private DHKeyAgreement2() {}

    public static void main(String argv[]) {
        try {
            String mode = "USE_SKIP_DH_PARAMS";

            DHKeyAgreement2 keyAgree = new DHKeyAgreement2();

            if (argv.length &gt; 1) {
                keyAgree.usage();
                throw new Exception("Wrong number of command options");
            } else if (argv.length == 1) {
                if (!(argv[0].equals("-gen"))) {
                    keyAgree.usage();
                    throw new Exception("Unrecognized flag: " + argv[0]);
                }
                mode = "GENERATE_DH_PARAMS";
            }

            keyAgree.run(mode);
        } catch (Exception e) {
            System.err.println("Error: " + e);
            System.exit(1);
        }
    }

    private void run(String mode) throws Exception {

        DHParameterSpec dhSkipParamSpec;

        if (mode.equals("GENERATE_DH_PARAMS")) {
            // Some central authority creates new DH parameters
            System.out.println
                ("Creating Diffie-Hellman parameters (takes VERY long) ...");
            AlgorithmParameterGenerator paramGen
                = AlgorithmParameterGenerator.getInstance("DH");
            paramGen.init(512);
            AlgorithmParameters params = paramGen.generateParameters();
            dhSkipParamSpec = (DHParameterSpec)params.getParameterSpec
                (DHParameterSpec.class);
        } else {
            // use some pre-generated, default DH parameters
            System.out.println("Using SKIP Diffie-Hellman parameters");
            dhSkipParamSpec = new DHParameterSpec(skip1024Modulus,
                                                  skip1024Base);
        }

        /*
         * Alice creates her own DH key pair, using the DH parameters from
         * above
         */
        System.out.println("ALICE: Generate DH keypair ...");
        KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance("DH");
        aliceKpairGen.initialize(dhSkipParamSpec);
        KeyPair aliceKpair = aliceKpairGen.generateKeyPair();

        // Alice creates and initializes her DH KeyAgreement object
        System.out.println("ALICE: Initialization ...");
        KeyAgreement aliceKeyAgree = KeyAgreement.getInstance("DH");
        aliceKeyAgree.init(aliceKpair.getPrivate());

        // Alice encodes her public key, and sends it over to Bob.
        byte[] alicePubKeyEnc = aliceKpair.getPublic().getEncoded();

        /*
         * Let's turn over to Bob. Bob has received Alice's public key
         * in encoded format.
         * He instantiates a DH public key from the encoded key material.
         */
        KeyFactory bobKeyFac = KeyFactory.getInstance("DH");
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec
            (alicePubKeyEnc);
        PublicKey alicePubKey = bobKeyFac.generatePublic(x509KeySpec);

        /*
         * Bob gets the DH parameters associated with Alice's public key. 
         * He must use the same parameters when he generates his own key
         * pair.
         */
        DHParameterSpec dhParamSpec = ((DHPublicKey)alicePubKey).getParams();

        // Bob creates his own DH key pair
        System.out.println("BOB: Generate DH keypair ...");
        KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance("DH");
        bobKpairGen.initialize(dhParamSpec);
        KeyPair bobKpair = bobKpairGen.generateKeyPair();

        // Bob creates and initializes his DH KeyAgreement object
        System.out.println("BOB: Initialization ...");
        KeyAgreement bobKeyAgree = KeyAgreement.getInstance("DH");
        bobKeyAgree.init(bobKpair.getPrivate());

        // Bob encodes his public key, and sends it over to Alice.
        byte[] bobPubKeyEnc = bobKpair.getPublic().getEncoded();

        /*
         * Alice uses Bob's public key for the first (and only) phase
         * of her version of the DH
         * protocol.
         * Before she can do so, she has to instanticate a DH public key
         * from Bob's encoded key material.
         */
        KeyFactory aliceKeyFac = KeyFactory.getInstance("DH");
        x509KeySpec = new X509EncodedKeySpec(bobPubKeyEnc);
        PublicKey bobPubKey = aliceKeyFac.generatePublic(x509KeySpec);
        System.out.println("ALICE: Execute PHASE1 ...");
        aliceKeyAgree.doPhase(bobPubKey, true);

        /*
         * Bob uses Alice's public key for the first (and only) phase
         * of his version of the DH
         * protocol.
         */
        System.out.println("BOB: Execute PHASE1 ...");
        bobKeyAgree.doPhase(alicePubKey, true);
            
        /*
         * At this stage, both Alice and Bob have completed the DH key
         * agreement protocol.
         * Both generate the (same) shared secret.
         */
        byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
        int aliceLen = aliceSharedSecret.length;

        byte[] bobSharedSecret = new byte[aliceLen];
        int bobLen;
        try {
            // show example of what happens if you
            // provide an output buffer that is too short
            bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 1);
        } catch (ShortBufferException e) {
            System.out.println(e.getMessage());
        }
        // provide output buffer of required size
        bobLen = bobKeyAgree.generateSecret(bobSharedSecret, 0);

        System.out.println("Alice secret: " + 
          toHexString(aliceSharedSecret));
        System.out.println("Bob secret: " + 
          toHexString(bobSharedSecret));

        if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))
            throw new Exception("Shared secrets differ");
        System.out.println("Shared secrets are the same");

        /*
         * Now let's return the shared secret as a SecretKey object
         * and use it for encryption. First, we generate SecretKeys for the
         * "DES" algorithm (based on the raw shared secret data) and
         * then we use DES in ECB mode
         * as the encryption algorithm. DES in ECB mode does not require any
         * parameters.
         *
         * Then we use DES in CBC mode, which requires an initialization
         * vector (IV) parameter. In CBC mode, you need to initialize the
         * Cipher object with an IV, which can be supplied using the
         * javax.crypto.spec.IvParameterSpec class. Note that you have to use
         * the same IV for encryption and decryption: If you use a different
         * IV for decryption than you used for encryption, decryption will
         * fail.
         *
         * Note: If you do not specify an IV when you initialize the
         * Cipher object for encryption, the underlying implementation
         * will generate a random one, which you have to retrieve using the
         * javax.crypto.Cipher.getParameters() method, which returns an 
         * instance of java.security.AlgorithmParameters. You need to transfer
         * the contents of that object (e.g., in encoded format, obtained via
         * the AlgorithmParameters.getEncoded() method) to the party who will
         * do the decryption. When initializing the Cipher for decryption,
         * the (reinstantiated) AlgorithmParameters object must be passed to
         * the Cipher.init() method.
         */
        System.out.println("Return shared secret as SecretKey object ...");
        // Bob
        // Note: The call to bobKeyAgree.generateSecret above reset the key
        // agreement object, so we call doPhase again prior to another
        // generateSecret call
        bobKeyAgree.doPhase(alicePubKey, true);
        SecretKey bobDesKey = bobKeyAgree.generateSecret("DES");

        // Alice
        // Note: The call to aliceKeyAgree.generateSecret above reset the key
        // agreement object, so we call doPhase again prior to another
        // generateSecret call
        aliceKeyAgree.doPhase(bobPubKey, true);
        SecretKey aliceDesKey = aliceKeyAgree.generateSecret("DES");

        /*
         * Bob encrypts, using DES in ECB mode
         */
        Cipher bobCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
        bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey);

        byte[] cleartext = "This is just an example".getBytes();
        byte[] ciphertext = bobCipher.doFinal(cleartext);

        /*
         * Alice decrypts, using DES in ECB mode
         */
        Cipher aliceCipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
        aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey);
        byte[] recovered = aliceCipher.doFinal(ciphertext);
            
        if (!java.util.Arrays.equals(cleartext, recovered))
            throw new Exception("DES in CBC mode recovered text is " +
              "different from cleartext");
        System.out.println("DES in ECB mode recovered text is " +
            "same as cleartext");    

        /*
         * Bob encrypts, using DES in CBC mode
         */
        bobCipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
        bobCipher.init(Cipher.ENCRYPT_MODE, bobDesKey);

        cleartext = "This is just an example".getBytes();
        ciphertext = bobCipher.doFinal(cleartext);
        // Retrieve the parameter that was used, and transfer it to Alice in
        // encoded format
        byte[] encodedParams = bobCipher.getParameters().getEncoded();

        /*
         * Alice decrypts, using DES in CBC mode
         */
        // Instantiate AlgorithmParameters object from parameter encoding
        // obtained from Bob
        AlgorithmParameters params = AlgorithmParameters.getInstance("DES");
        params.init(encodedParams);
        aliceCipher = Cipher.getInstance("DES/CBC/PKCS5Padding");
        aliceCipher.init(Cipher.DECRYPT_MODE, aliceDesKey, params);
        recovered = aliceCipher.doFinal(ciphertext);
            
        if (!java.util.Arrays.equals(cleartext, recovered))
            throw new Exception("DES in CBC mode recovered text is " +
              "different from cleartext");
        System.out.println("DES in CBC mode recovered text is " +
            "same as cleartext");    
    }

    /*
     * Converts a byte to hex digit and writes to the supplied buffer
     */
    private void byte2hex(byte b, StringBuffer buf) {
        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        int high = ((b &amp; 0xf0) &gt;&gt; 4);
        int low = (b &amp; 0x0f);
        buf.append(hexChars[high]);
        buf.append(hexChars[low]);
    }

    /*
     * Converts a byte array to hex string
     */
    private String toHexString(byte[] block) {
        StringBuffer buf = new StringBuffer();

        int len = block.length;

        for (int i = 0; i &lt; len; i++) {
             byte2hex(block[i], buf);
             if (i &lt; len-1) {
                 buf.append(":");
             }
        } 
        return buf.toString();
    }

    /*
     * Prints the usage of this test.
     */
    private void usage() {
        System.err.print("DHKeyAgreement usage: ");
        System.err.println("[-gen]");
    }

    // The 1024 bit Diffie-Hellman modulus values used by SKIP
    private static final byte skip1024ModulusBytes[] = {
        (byte)0xF4, (byte)0x88, (byte)0xFD, (byte)0x58,
        (byte)0x4E, (byte)0x49, (byte)0xDB, (byte)0xCD,
        (byte)0x20, (byte)0xB4, (byte)0x9D, (byte)0xE4,
        (byte)0x91, (byte)0x07, (byte)0x36, (byte)0x6B,
        (byte)0x33, (byte)0x6C, (byte)0x38, (byte)0x0D,
        (byte)0x45, (byte)0x1D, (byte)0x0F, (byte)0x7C,
        (byte)0x88, (byte)0xB3, (byte)0x1C, (byte)0x7C,
        (byte)0x5B, (byte)0x2D, (byte)0x8E, (byte)0xF6,
        (byte)0xF3, (byte)0xC9, (byte)0x23, (byte)0xC0,
        (byte)0x43, (byte)0xF0, (byte)0xA5, (byte)0x5B,
        (byte)0x18, (byte)0x8D, (byte)0x8E, (byte)0xBB,
        (byte)0x55, (byte)0x8C, (byte)0xB8, (byte)0x5D,
        (byte)0x38, (byte)0xD3, (byte)0x34, (byte)0xFD,
        (byte)0x7C, (byte)0x17, (byte)0x57, (byte)0x43,
        (byte)0xA3, (byte)0x1D, (byte)0x18, (byte)0x6C,
        (byte)0xDE, (byte)0x33, (byte)0x21, (byte)0x2C,
        (byte)0xB5, (byte)0x2A, (byte)0xFF, (byte)0x3C,
        (byte)0xE1, (byte)0xB1, (byte)0x29, (byte)0x40,
        (byte)0x18, (byte)0x11, (byte)0x8D, (byte)0x7C,
        (byte)0x84, (byte)0xA7, (byte)0x0A, (byte)0x72,
        (byte)0xD6, (byte)0x86, (byte)0xC4, (byte)0x03,
        (byte)0x19, (byte)0xC8, (byte)0x07, (byte)0x29,
        (byte)0x7A, (byte)0xCA, (byte)0x95, (byte)0x0C,
        (byte)0xD9, (byte)0x96, (byte)0x9F, (byte)0xAB,
        (byte)0xD0, (byte)0x0A, (byte)0x50, (byte)0x9B,
        (byte)0x02, (byte)0x46, (byte)0xD3, (byte)0x08,
        (byte)0x3D, (byte)0x66, (byte)0xA4, (byte)0x5D,
        (byte)0x41, (byte)0x9F, (byte)0x9C, (byte)0x7C,
        (byte)0xBD, (byte)0x89, (byte)0x4B, (byte)0x22,
        (byte)0x19, (byte)0x26, (byte)0xBA, (byte)0xAB,
        (byte)0xA2, (byte)0x5E, (byte)0xC3, (byte)0x55,
        (byte)0xE9, (byte)0x2F, (byte)0x78, (byte)0xC7
    };

    // The SKIP 1024 bit modulus
    private static final BigInteger skip1024Modulus
    = new BigInteger(1, skip1024ModulusBytes);

    // The base used with the SKIP 1024 bit modulus
    private static final BigInteger skip1024Base = BigInteger.valueOf(2);
}
</pre>

<hr>

</li><li><a name="DH3Ex"><h3>Diffie-Hellman Key Exchange between 3 Parties</h3></a>

<pre>/*
 * Copyright 1997-2001 by Oracle and/or its affiliates.,
 * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Oracle and/or its affiliates. ("Confidential Information").  You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Sun.
 */

import java.io.*;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.*;
import java.security.interfaces.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
import com.sun.crypto.provider.SunJCE;

/**
 * This program executes the Diffie-Hellman key agreement protocol
 * between 3 parties: Alice, Bob, and Carol.
 *
 * We use the same 1024-bit prime modulus and base generator that are 
 * used by SKIP.
 */

public class DHKeyAgreement3 {

    private DHKeyAgreement3() {}

    public static void main(String argv[]) {
        try {
            DHKeyAgreement3 keyAgree = new DHKeyAgreement3();
            keyAgree.run();
        } catch (Exception e) {
            System.err.println("Error: " + e);
            System.exit(1);
        }
    }

    private void run() throws Exception {

        DHParameterSpec dhSkipParamSpec;

        System.out.println("Using SKIP Diffie-Hellman parameters");
        dhSkipParamSpec = new DHParameterSpec(skip1024Modulus, skip1024Base);

        // Alice creates her own DH key pair
        System.out.println("ALICE: Generate DH keypair ...");
        KeyPairGenerator aliceKpairGen = KeyPairGenerator.getInstance("DH");
        aliceKpairGen.initialize(dhSkipParamSpec);
        KeyPair aliceKpair = aliceKpairGen.generateKeyPair();

        // Bob creates his own DH key pair
        System.out.println("BOB: Generate DH keypair ...");
        KeyPairGenerator bobKpairGen = KeyPairGenerator.getInstance("DH");
        bobKpairGen.initialize(dhSkipParamSpec);
        KeyPair bobKpair = bobKpairGen.generateKeyPair();

        // Carol creates her own DH key pair
        System.out.println("CAROL: Generate DH keypair ...");
        KeyPairGenerator carolKpairGen = KeyPairGenerator.getInstance("DH");
        carolKpairGen.initialize(dhSkipParamSpec);
        KeyPair carolKpair = carolKpairGen.generateKeyPair();


        // Alice initialize
        System.out.println("ALICE: Initialize ...");
        KeyAgreement aliceKeyAgree = KeyAgreement.getInstance("DH");
        aliceKeyAgree.init(aliceKpair.getPrivate());

        // Bob initialize
        System.out.println("BOB: Initialize ...");
        KeyAgreement bobKeyAgree = KeyAgreement.getInstance("DH");
        bobKeyAgree.init(bobKpair.getPrivate());

        // Carol initialize
        System.out.println("CAROL: Initialize ...");
        KeyAgreement carolKeyAgree = KeyAgreement.getInstance("DH");
        carolKeyAgree.init(carolKpair.getPrivate());


        // Alice uses Carol's public key
        Key ac = aliceKeyAgree.doPhase(carolKpair.getPublic(), false);

        // Bob uses Alice's public key
        Key ba = bobKeyAgree.doPhase(aliceKpair.getPublic(), false);

        // Carol uses Bob's public key
        Key cb = carolKeyAgree.doPhase(bobKpair.getPublic(), false);


        // Alice uses Carol's result from above
        aliceKeyAgree.doPhase(cb, true);

        // Bob uses Alice's result from above
        bobKeyAgree.doPhase(ac, true);

        // Carol uses Bob's result from above
        carolKeyAgree.doPhase(ba, true);


        // Alice, Bob and Carol compute their secrets
        byte[] aliceSharedSecret = aliceKeyAgree.generateSecret();
        System.out.println("Alice secret: " + toHexString(aliceSharedSecret));

        byte[] bobSharedSecret = bobKeyAgree.generateSecret();
        System.out.println("Bob secret: " + toHexString(bobSharedSecret));

        byte[] carolSharedSecret = carolKeyAgree.generateSecret();
        System.out.println("Carol secret: " + toHexString(carolSharedSecret));


        // Compare Alice and Bob
        if (!java.util.Arrays.equals(aliceSharedSecret, bobSharedSecret))
            throw new Exception("Alice and Bob differ");
        System.out.println("Alice and Bob are the same");

        // Compare Bob and Carol
        if (!java.util.Arrays.equals(bobSharedSecret, carolSharedSecret))
            throw new Exception("Bob and Carol differ");
        System.out.println("Bob and Carol are the same");
    }


    /*
     * Converts a byte to hex digit and writes to the supplied buffer
     */
    private void byte2hex(byte b, StringBuffer buf) {
        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        int high = ((b &amp; 0xf0) &gt;&gt; 4);
        int low = (b &amp; 0x0f);
        buf.append(hexChars[high]);
        buf.append(hexChars[low]);
    }

    /*
     * Converts a byte array to hex string
     */
    private String toHexString(byte[] block) {
        StringBuffer buf = new StringBuffer();

        int len = block.length;

        for (int i = 0; i &lt; len; i++) {
             byte2hex(block[i], buf);
             if (i &lt; len-1) {
                 buf.append(":");
             }
        } 
        return buf.toString();
    }

    /*
     * Prints the usage of this test.
     */
    private void usage() {
        System.err.print("DHKeyAgreement usage: ");
        System.err.println("[-gen]");
    }

    // The 1024 bit Diffie-Hellman modulus values used by SKIP
    private static final byte skip1024ModulusBytes[] = {
        (byte)0xF4, (byte)0x88, (byte)0xFD, (byte)0x58,
        (byte)0x4E, (byte)0x49, (byte)0xDB, (byte)0xCD,
        (byte)0x20, (byte)0xB4, (byte)0x9D, (byte)0xE4,
        (byte)0x91, (byte)0x07, (byte)0x36, (byte)0x6B,
        (byte)0x33, (byte)0x6C, (byte)0x38, (byte)0x0D,
        (byte)0x45, (byte)0x1D, (byte)0x0F, (byte)0x7C,
        (byte)0x88, (byte)0xB3, (byte)0x1C, (byte)0x7C,
        (byte)0x5B, (byte)0x2D, (byte)0x8E, (byte)0xF6,
        (byte)0xF3, (byte)0xC9, (byte)0x23, (byte)0xC0,
        (byte)0x43, (byte)0xF0, (byte)0xA5, (byte)0x5B,
        (byte)0x18, (byte)0x8D, (byte)0x8E, (byte)0xBB,
        (byte)0x55, (byte)0x8C, (byte)0xB8, (byte)0x5D,
        (byte)0x38, (byte)0xD3, (byte)0x34, (byte)0xFD,
        (byte)0x7C, (byte)0x17, (byte)0x57, (byte)0x43,
        (byte)0xA3, (byte)0x1D, (byte)0x18, (byte)0x6C,
        (byte)0xDE, (byte)0x33, (byte)0x21, (byte)0x2C,
        (byte)0xB5, (byte)0x2A, (byte)0xFF, (byte)0x3C,
        (byte)0xE1, (byte)0xB1, (byte)0x29, (byte)0x40,
        (byte)0x18, (byte)0x11, (byte)0x8D, (byte)0x7C,
        (byte)0x84, (byte)0xA7, (byte)0x0A, (byte)0x72,
        (byte)0xD6, (byte)0x86, (byte)0xC4, (byte)0x03,
        (byte)0x19, (byte)0xC8, (byte)0x07, (byte)0x29,
        (byte)0x7A, (byte)0xCA, (byte)0x95, (byte)0x0C,
        (byte)0xD9, (byte)0x96, (byte)0x9F, (byte)0xAB,
        (byte)0xD0, (byte)0x0A, (byte)0x50, (byte)0x9B,
        (byte)0x02, (byte)0x46, (byte)0xD3, (byte)0x08,
        (byte)0x3D, (byte)0x66, (byte)0xA4, (byte)0x5D,
        (byte)0x41, (byte)0x9F, (byte)0x9C, (byte)0x7C,
        (byte)0xBD, (byte)0x89, (byte)0x4B, (byte)0x22,
        (byte)0x19, (byte)0x26, (byte)0xBA, (byte)0xAB,
        (byte)0xA2, (byte)0x5E, (byte)0xC3, (byte)0x55,
        (byte)0xE9, (byte)0x2F, (byte)0x78, (byte)0xC7
    };

    // The SKIP 1024 bit modulus
    private static final BigInteger skip1024Modulus
    = new BigInteger(1, skip1024ModulusBytes);

    // The base used with the SKIP 1024 bit modulus
    private static final BigInteger skip1024Base = BigInteger.valueOf(2);
}
</pre>

<hr>

</li><li><a name="BlowKeyEx"><h3>Blowfish Example</h3></a>

<pre>/*
 * Copyright 1997-2001 by Oracle and/or its affiliates.,
 * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Oracle and/or its affiliates. ("Confidential Information").  You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Sun.
 */

import java.security.*;
import javax.crypto.*;
import javax.crypto.spec.*;

/**
 * This program generates a Blowfish key, retrieves its raw bytes, and 
 * then reinstantiates a Blowfish key from the key bytes.
 * The reinstantiated key is used to initialize a Blowfish cipher for
 * encryption.
 */

public class BlowfishKey {

    public static void main(String[] args) throws Exception {

        KeyGenerator kgen = KeyGenerator.getInstance("Blowfish");
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "Blowfish");

        Cipher cipher = Cipher.getInstance("Blowfish");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = 
            cipher.doFinal("This is just an example".getBytes());
    }
}
</pre>

<hr>

</li><li><a name="HmacEx"><h3>HMAC-MD5 Example</h3></a>

<pre>/*
 * Copyright 1997-2001 by Oracle and/or its affiliates.,
 * 901 San Antonio Road, Palo Alto, California, 94303, U.S.A.
 * All rights reserved.
 *
 * This software is the confidential and proprietary information
 * of Oracle and/or its affiliates. ("Confidential Information").  You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Sun.
 */

import java.security.*;
import javax.crypto.*;

/**
 * This program demonstrates how to generate a secret-key object for
 * HMAC-MD5, and initialize an HMAC-MD5 object with it.
 */

public class initMac {

    public static void main(String[] args) throws Exception {

        // Generate secret key for HMAC-MD5
        KeyGenerator kg = KeyGenerator.getInstance("HmacMD5");
        SecretKey sk = kg.generateKey();

        // Get instance of Mac object implementing HMAC-MD5, and 
        // initialize it with the above secret key
        Mac mac = Mac.getInstance("HmacMD5");
        mac.init(sk);
        byte[] result = mac.doFinal("Hi There".getBytes());
    }
}
</pre>

</li></ul>

<!-- Body text ends here -->

<!-- ============================================================== -->
<hr size="3" noshade="">

<table summary="layout" border="0" width="100%">

<tbody><tr valign="TOP">

<td>

<p><font size="-2">
   <a href="http://docs.oracle.com/javase/1.4.2/docs/relnotes/SMICopyright.html">Copyright &#169;</a> 2003, 2010
   <a href="http://www.oracle.com/">Oracle and/or its affiliates.</a>
    All rights reserved.</font></p>

   <font size="-1">
   Please send comments to: <a href="mailto:java-security@java.sun.com">java-security@java.sun.com</a>.
   </font>

</td>

<td align="RIGHT">

   <img src="./Java Cryptography Extension_files/sunlogo64x30.gif" alt="Sun" border="0">
   <br>
   <font size="+1">
   <i> </i>
   </font>

</td>

</tr>

</tbody></table>

<!-- Created: Wed Jan 20 16:30:48 PST 1999 -->
<!-- hhmts start -->
Last modified: 10 Jan 2002
<!-- hhmts end -->

<!-- Start SiteCatalyst code   -->
<script language="JavaScript" src="./Java Cryptography Extension_files/s_code_download.js"></script>
<script language="JavaScript" src="./Java Cryptography Extension_files/s_code.js"></script>
 
<!-- ********** DO NOT ALTER ANYTHING BELOW THIS LINE ! *********** -->
<!--  Below code will send the info to Omniture server -->
<script language="javascript">var s_code=s.t();if(s_code)document.write(s_code)</script>
 
<!-- End SiteCatalyst code -->




</body></html>